Expertenanalyse und Implementierungsleitfaden für ein VPN-Administrationssystem auf Debian 12

Dieses Dokument stellt eine umfassende technische Analyse und einen Implementierungsleitfaden für ein fortschrittliches WireGuard VPN-Administrationssystem auf Debian 12 (Bookworm) dar. Es richtet sich an erfahrene Systemadministratoren und Netzwerkingenieure. Das Dokument gliedert sich in drei Hauptteile:

    Strategische Überprüfung und Architekturoptimierung: Eine detaillierte Analyse des ursprünglichen Konzepts, Identifizierung potenzieller Schwachstellen und Vorstellung von architektonischen Verbesserungen für mehr Stabilität, Sicherheit und Leistung.

    Implementierungsleitfaden vpn-installer.sh: Der vollständig kommentierte Quellcode und die Erläuterung des Installationsskripts, das die gesamte Serverumgebung automatisiert einrichtet.

    Implementierungsleitfaden vpn-admin: Der vollständig kommentierte Quellcode und die Erläuterung des Verwaltungswerkzeugs für den gesamten Lebenszyklus von Benutzern und Peers.

Teil I: Strategische Überprüfung und Architekturoptimierung

Dieser Teil dient als formale Überprüfung des vorgelegten Konzepts. Er geht über eine einfache Fehlerprüfung hinaus und bietet strategische Empfehlungen, um sicherzustellen, dass die endgültige Implementierung robust, sicher und wartbar ist. Potenzielle Konflikte und nicht explizit genannte Komplexitäten werden identifiziert und gelöst.

Abschnitt 1: Validierung der Kernarchitektur

Die vorgeschlagene Architektur bildet eine solide Grundlage für ein leistungsfähiges und modernes VPN-Gateway.

1.1 Komponentensynergie und Begründung

Die Auswahl der Kerntechnologien ist strategisch fundiert. Die Kombination aus WireGuard für den VPN-Transport, nftables für die zustandsbehaftete Paketfilterung, tc für das Traffic-Shaping und einem zweistufigen DNS-Stack mit Unbound und AdGuard Home stellt eine erstklassige, moderne Architektur dar. Jede Komponente ist hochleistungsfähig und lässt sich gut mit den anderen integrieren, vorausgesetzt, die Schnittstellen werden sorgfältig verwaltet. WireGuard bietet eine schlanke und performante VPN-Grundlage, während nftables als dessen moderner Nachfolger iptables überlegen ist und eine klarere Syntax bietet. AdGuard Home ermöglicht eine netzwerkweite Filterung von Werbung und Trackern, was einen erheblichen Mehrwert darstellt.  

1.2 Identifizierung kritischer Interaktionspunkte

Die wahre Komplexität dieses Projekts liegt nicht in den einzelnen Komponenten, sondern in ihrer Interaktion. Zwei Bereiche sind hierbei von entscheidender Bedeutung:

    Zustandssynchronisation: Die größte Herausforderung besteht darin, sicherzustellen, dass der vom vpn-admin-Skript verwaltete Zustand (gespeichert in /etc/peers/) jederzeit perfekt mit dem laufenden Zustand von WireGuard, nftables und tc synchronisiert ist. Ein Fehler in dieser Synchronisation könnte zu Sicherheitslücken (z.B. ein Peer wird nicht korrekt blockiert) oder zu Funktionsstörungen (z.B. falsche Bandbreitenlimits) führen.

    Logik des Paketflusses: Das System manipuliert Pakete auf mehreren Ebenen des Netzwerkstacks: WireGuard-Verschlüsselung, nftables-Markierung und NAT, sowie tc-Klassifizierung und -Shaping. Ein klares und präzises Verständnis der Reise eines Pakets durch den Linux-Kernel ist unerlässlich, damit die Regeln korrekt und in der richtigen Reihenfolge angewendet werden. Beispielsweise muss die Markierung eines Pakets in nftables erfolgen, bevor tc diese Markierung zur Klassifizierung verwenden kann.   

Um die Verantwortlichkeiten klar zu definieren und Mehrdeutigkeiten zu vermeiden, fasst die folgende Tabelle die Rolle jeder Komponente zusammen.

Komponente
	

Rolle in der Architektur
	

Begründung & Hauptmerkmale

WireGuard
	

Sicherer VPN-Tunnel-Transport
	

Hohe Performance, moderne Kryptographie, schlanke Codebasis. Bildet das Kernstück des VPN-Dienstes.  

nftables
	

Firewall, NAT, Paketmarkierung
	

Moderner Paketfilter für Linux. Implementiert den Kill-Switch, NAT für den Internetzugang der Clients und markiert Pakete zur Weiterverarbeitung durch tc.  

tc (HTB)
	

Egress Traffic-Shaping (Upload)
	

Hierarchical Token Bucket (HTB) ermöglicht die Erstellung von Bandbreitenklassen für verschiedene Benutzergruppen (Upload-Raten).  

ifb-Modul
	

Ingress Traffic-Shaping (Download)
	

Das Intermediate Functional Block (IFB) Device ist notwendig, um ankommenden Verkehr (Download) umzuleiten und ihn als ausgehenden Verkehr zu behandeln, was echtes Shaping ermöglicht.  

Unbound
	

DNSSEC-validierender rekursiver DNS-Resolver
	

Dient als sicherer Upstream-Resolver ausschließlich für AdGuard Home. Stellt die Integrität von DNS-Antworten durch DNSSEC-Validierung sicher.

AdGuard Home
	

Filternder DNS-Server & DHCP (optional)
	

Blockiert Werbung und Tracker für alle VPN-Clients. Nutzt Unbound als vertrauenswürdige Quelle. Bietet eine Web-Oberfläche zur Verwaltung.  

jq
	

JSON-Prozessor
	

Unerlässlich für das zuverlässige Parsen und Bearbeiten der meta.json-Dateien der Peers in den Bash-Skripten.  

qrencode
	

QR-Code-Generator
	

Erstellt QR-Codes aus den Client-Konfigurationsdateien für eine einfache Einrichtung auf mobilen Geräten.  

systemd
	

Service- & Timer-Management
	

Stellt die Persistenz der Dienste sicher (WireGuard, nftables etc.) und führt automatisierte Wartungsaufgaben (Quota-Reset, Ablauf-Check) über Timer aus.  

Abschnitt 2: Kritische Implementierungsentscheidungen & Optimierungen

Dieser Abschnitt befasst sich mit spezifischen, hochwirksamen technischen Entscheidungen, die im Konzept entweder mehrdeutig sind oder einen robusteren Ansatz erfordern.

2.1 WireGuard-Konfigurationsmanagement: Das SaveConfig-Dilemma

Das Konzept listet SaveConfig = true als optionale Einstellung in der wg0.conf. Eine Analyse der Funktionsweise von wg-quick zeigt, dass diese Option in direktem Konflikt mit einem externen Verwaltungsskript steht.  

SaveConfig=true weist wg-quick an, beim Herunterfahren des Interfaces den aktuellen Live-Zustand in die Konfigurationsdatei zurückzuschreiben. Dies würde die deterministisch aus den Metadaten generierte Konfiguration unseres vpn-admin-Skripts überschreiben und zerstören.  

Dies ist keine bloße Konfigurationsentscheidung, sondern eine grundlegende Festlegung über die "Quelle der Wahrheit" (Source of Truth) des Systems. Die Aktivierung von SaveConfig=true würde zwei konkurrierende Autoritäten für den Zustand des VPN schaffen: das vpn-admin-Skript und den wg-quick-Dienst selbst. Dies führt zu einem instabilen, unvorhersehbaren System, in dem Änderungen stillschweigend rückgängig gemacht werden oder verloren gehen können. Ein robustes System muss einen einzigen, unidirektionalen Kontrollfluss haben. Das vpn-admin-Skript muss die alleinige Autorität über die Konfiguration sein.

Empfehlung: Die Implementierung wird SaveConfig = false fest kodieren. Das vpn-admin-Skript ist allein verantwortlich für die Erstellung der vollständigen wg0.conf aus den Peer-Metadaten. Änderungen werden atomar und ohne Unterbrechung aktiver Sitzungen mittels wg syncconf wg0 <(wg-quick strip wg0) angewendet. Dieser Befehl synchronisiert die Live-Konfiguration mit einer neuen Konfiguration, die aus der alten "gestrippt" und mit neuen Peer-Informationen angereichert wird, ohne das Interface neu zu starten.  

2.2 Ingress (Download) Traffic-Shaping: Der IFB-Imperativ

Die Anforderung im Konzept, gestaffelte Download-Geschwindigkeitsbegrenzungen durchzusetzen, ist ein Kernmerkmal. Es wird jedoch eine entscheidende technische Einschränkung des Traffic-Control-Subsystems von Linux übersehen. Standard-ingress-qdiscs können nur "Policing" durchführen, d.h. Pakete, die eine bestimmte Rate überschreiten, werden verworfen. Dies führt bei TCP-basierten Protokollen zu einer schlechten Performance durch wiederholte Retransmissions. Echtes "Shaping", bei dem Pakete zur Glättung von Bursts in eine Warteschlange gestellt und verzögert werden, ist nur für ausgehenden (Egress) Verkehr verfügbar.  

Die Recherche zeigt unmissverständlich, dass zur Erreichung des Ziels ein Intermediate Functional Block (IFB) Device zwingend erforderlich ist. Dies ist eine nicht offensichtliche, aber wesentliche Komponente. Der gesamte ankommende Verkehr von der WAN-Schnittstelle muss auf eine virtuelle  

ifb0-Schnittstelle gespiegelt werden. Dort kann er dann als ausgehender Verkehr behandelt und mit der HTB-qdisc ordnungsgemäß geformt werden. Das IFB-Device ist somit eine zwingende, bisher nicht genannte Abhängigkeit, damit das Konzept des Benutzers realisiert werden kann.

Empfehlung: Das vpn-installer.sh-Skript wird die IFB-Infrastruktur transparent einrichten. Dies beinhaltet das Laden des ifb-Kernelmoduls, das Erstellen des ifb0-Geräts und das Hinzufügen des notwendigen tc filter auf der WAN-Schnittstelle, um den gesamten Ingress-Verkehr auf ifb0 umzuleiten. Die apply_rules-Funktion des vpn-admin-Skripts wird dann so konzipiert, dass sie zwei Sätze von tc-Klassen und -Filtern verwaltet: einen auf der WAN-Schnittstelle für das Upload-Shaping und einen auf der ifb0-Schnittstelle für das Download-Shaping.

2.3 Firewall-Strategie zur Umleitung blockierter Peers

Das Konzept, "Gesperrte" Peers auf eine Landing-Page umzuleiten, ist mit nftables realisierbar. Eine einfache dnat-Regel ist jedoch nicht ausreichend, insbesondere wenn man eine saubere und skalierbare Lösung anstrebt. Die Implementierung erfordert einen mehrstufigen Prozess innerhalb des nftables-Regelwerks, der das im Konzept bereits angedachte Prinzip der gruppenbasierten Markierung nutzt.

Der Prozess sieht wie folgt aus:

    Ein Peer wird in seiner meta.json als "Gesperrt" markiert.

    Die apply_rules-Funktion liest diesen Status.

    Sie generiert eine nftables-Regel in der prerouting-Chain der nat-Tabelle, die Pakete anhand der Quell-IP-Adresse des Peers (ip saddr 10.42.0.X) identifiziert und eine eindeutige Firewall-Markierung setzt (z. B. meta mark set 0xBLOCKED).

    Ein separater, hochpriotärer Satz von Regeln in der prerouting-Chain reagiert dann auf diese 0xBLOCKED-Markierung für Verkehr auf den Ports 80 (HTTP) und 443 (HTTPS) und wendet ein dnat an, um ihn zu einem lokalen Webserver umzuleiten.   

Diese Entkopplung von Peer-Identifikation und Umleitungsaktion macht das Regelwerk sauberer, modularer und leichter wartbar. Für die HTTPS-Umleitung ist zu beachten, dass der Server die SSL-Verbindung für beliebige Domains nicht terminieren kann. Der praktischste Ansatz ist die Umleitung auf eine dedizierte HTTP/S-Landingpage, die vom Administrator gehostet wird und deren Zertifikat auf dem Server vorhanden ist.

Empfehlung: Der Installer wird optional einen schlanken Webserver (z. B. nginx-light) installieren, der vorkonfiguriert ist, um eine einfache "Zugang gesperrt"-Seite auszuliefern. Das vpn-admin-Skript verwaltet dann die dynamischen nftables-Markierungs- und DNAT-Regeln.

Abschnitt 3: Verbesserungen bei Sicherheit, Robustheit und Automatisierung

Dieser Abschnitt führt proaktive Maßnahmen ein, um das System gegen häufige Ausfallmodi und Sicherheitsrisiken zu härten.

3.1 Skript-Härtung und Gleichzeitigkeitskontrolle (Concurrency Control)

Das Design sieht automatisierte Skripte vor, die von systemd-Timern ausgeführt werden (--quota-reset, --expiry-check). Dies birgt das Risiko einer Race Condition, wenn ein Administrator vpn-admin interaktiv ausführt, genau in dem Moment, in dem ein zeitgesteuerter Job startet. Dies könnte zu korrupten JSON-Dateien oder einem nur teilweise angewendeten Regelsatz führen.

Der gesamte Prozess der Zustandsänderung muss als atomare Transaktion behandelt werden. Eine dateibasierte Sperre (Lock File) ist der gebräuchlichste und effektivste Weg, dies im Shell-Skripting zu erreichen. Die Recherche zeigt, dass naive Prüfungen wie if [ -f lockfile ] fehlerhaft sind, da sie nicht atomar sind. Ein robusteres Werkzeug wie  

flock ist erforderlich. Mehrere Prozesse (vpn-admin interaktiv, vpn-admin --expiry-check etc.) werden dieselben Dateien (/etc/peers/*) und Systemzustände (nftables, tc) modifizieren. Unkontrollierter gleichzeitiger Zugriff ist ein Rezept für eine Katastrophe. Daher ist eine gegenseitige Ausslusssperre (Mutex) nicht optional, sondern eine Anforderung für ein zuverlässiges System. flock ist das ideale Werkzeug, da es Teil von util-linux (auf Debian vorhanden) ist und die automatische Bereinigung beim Beenden des Skripts handhabt.  

Empfehlung: Alle Skripte beginnen mit set -euo pipefail für eine strikte Fehlerbehandlung. Das vpn-admin-Skript wird seine Hauptausführungslogik in einen flock -n /var/run/vpn-admin.lock-Aufruf einbetten. Dies stellt sicher, dass nur eine Instanz des Skripts – ob interaktiv oder automatisiert – die Konfiguration des Systems zu einem beliebigen Zeitpunkt ändern kann, wodurch Race Conditions verhindert werden.

3.2 Proaktive Lösung von DNS-Dienstkonflikten

Eine Standardinstallation von Debian 12 verwendet systemd-resolved, das einen Stub-Listener an 127.0.0.1:53 bindet. Dies steht in direktem Konflikt mit dem Standard-DNS-Port von AdGuard Home, was dazu führen würde, dass die Installation fehlschlägt.  

Ein wirklich "experten-level" Installationsskript sollte nicht fehlschlagen und den Benutzer anweisen, ein häufiges Problem manuell zu beheben. Es sollte es antizipieren und programmatisch lösen. Der Konflikt und seine Lösung sind gut dokumentiert: Der Stub-Listener muss deaktiviert werden. Ein automatisiertes Skript ist in der Lage, den konkurrierenden Prozess zu überprüfen und die Korrektur anzuwenden. Das Einbauen dieser Logik in den Installer hebt ihn von einer einfachen Befehlssequenz zu einem robusten, intelligenten Provisionierungswerkzeug.

Empfehlung: Das vpn-installer.sh-Skript wird eine dedizierte Funktion enthalten, um dies zu handhaben. Es wird ss -tulnp | grep '127.0.0.1:53.*systemd-resolve' verwenden, um den Konflikt zu erkennen. Falls gefunden, wird es automatisch /etc/systemd/resolved.conf.d/adguardhome.conf mit dem Inhalt DNSStubListener=no erstellen, /etc/resolv.conf neu verlinken, um auf /run/systemd/resolve/resolv.conf zu zeigen, und den systemd-resolved-Dienst neu starten, um eine nahtlose AdGuard Home-Einrichtung zu gewährleisten.  

3.3 Robuste Erkennung von Netzwerkparametern

Das Skript muss die primäre öffentliche IP-Adresse und die WAN-Schnittstelle des Systems zuverlässig erkennen. Veraltete und fehleranfällige Methoden wie das Parsen von ifconfig sind zu vermeiden.  

Die zuverlässigste Methode ist die Verwendung der JSON-Ausgabe moderner iproute2-Werkzeuge, aber man kann nicht davon ausgehen, dass immer die neueste Version vorhanden ist. Ein robustes Skript sollte die beste Methode bevorzugen und bei Bedarf auf eine weniger ideale, aber immer noch funktionale Alternative zurückgreifen. ip -j route get 1.1.1.1 liefert strukturiertes, leicht zu parsende JSON-Daten, was die ideale Eingabe für ein Skript ist, das jq verwendet. Wenn  

jq jedoch noch nicht installiert ist oder eine ältere ip-Version das -j-Flag nicht unterstützt, würde das Skript fehlschlagen. Ein besserer Ansatz ist es, auf jq und das JSON-Flag zu testen, es bei Verfügbarkeit zu verwenden und andernfalls auf das Parsen der reinen Textausgabe mit einem zuverlässigen awk- oder sed-Befehl zurückzugreifen, wie ebenfalls in der Recherche dokumentiert.  

Empfehlung: Die Funktion zur Parametererkennung in vpn-installer.sh wird mit dieser Primär-/Fallback-Logik implementiert, um sicherzustellen, dass sie über geringfügige Variationen in einer Debian 12-Umgebung hinweg zuverlässig funktioniert.

Teil II: Implementierungsleitfaden: vpn-installer.sh

Dieser Teil präsentiert den vollständig kommentierten Quellcode für das Installationsskript. Jede funktionale Einheit wird detailliert erklärt, wobei die Erkenntnisse aus Teil I integriert werden. Das Skript ist darauf ausgelegt, eine vollständige und schlüsselfertige VPN-Server-Umgebung auf einem sauberen Debian 12-System zu erstellen.

Abschnitt 4: Initialisierung und Systemvorbereitung

Das Skript beginnt mit grundlegenden Überprüfungen und der Vorbereitung des Systems, um eine stabile Basis für die nachfolgenden Installationsschritte zu schaffen.
Bash

#!/bin/bash
#
# vpn-installer.sh: Vollautomatisches Installationsskript für eine
# WireGuard VPN-Umgebung mit AdGuard, Unbound, nftables und tc.
#

# --- Strikter Modus und Fehlerbehandlung ---
# set -e: Beendet das Skript sofort, wenn ein Befehl mit einem Fehlercode > 0 endet.
# set -u: Behandelt nicht gesetzte Variablen als Fehler.
# set -o pipefail: Der Exit-Code einer Pipe ist der des letzten fehlschlagenden Befehls.
set -euo pipefail

# --- Globale Variablen und Konstanten ---
readonly SCRIPT_VERSION="1.0.0"
readonly REQUIRED_DEBIAN_VERSION="12"
readonly VPN_CONFIG_DIR="/etc/vpn-admin"
readonly VPN_PEERS_DIR="/etc/peers"
readonly VPN_LOG_DIR="/var/log/vpn-admin"
readonly VPN_BACKUP_DIR="/var/backups/vpn-admin"
readonly ADMIN_TOOL_PATH="/usr/local/bin/vpn-admin"
readonly LOCK_FILE="/var/run/vpn-admin.lock"

# --- Hilfsfunktionen für die Ausgabe ---
info() { echo -e "\e[34m[INFO]\e\e\e[0m $1"; exit 1; }
ok() { echo -e "\e[32m[OK]\e]; then
    error "Dieses Skript muss als 'root' ausgeführt werden. Bitte 'sudo./vpn-installer.sh' verwenden."
fi

# 2. Debian-Version-Check
if [[! -f /etc/debian_version ]] ||! grep -q "^\s*${REQUIRED_DEBIAN_VERSION}" /etc/os-release; then
    error "Dieses Skript ist nur für Debian ${REQUIRED_DEBIAN_VERSION} (Bookworm) ausgelegt."
fi

# --- System aktualisieren und Basispakete installieren ---
info "Aktualisiere das System und installiere notwendige Pakete..."
# Temporär einen öffentlichen DNS setzen, falls /etc/resolv.conf fehlerhaft ist
# Dies stellt sicher, dass 'apt' zuverlässig funktioniert.
if! grep -q "nameserver" /etc/resolv.conf; then
    warn "/etc/resolv.conf ist leer. Setze temporär 8.8.8.8 als Nameserver."
    echo "nameserver 8.8.8.8" > /etc/resolv.conf
fi

apt-get update
apt-get upgrade -y

# Installation aller im Konzept geforderten Tools
apt-get install -y \
    wireguard-tools \
    nftables \
    unbound \
    curl \
    jq \
    qrencode \
    iproute2 \
    htop \
    util-linux \
    nginx-light \
    ipcalc

ok "System ist aktuell und alle Basispakete sind installiert."

Abschnitt 5: Interaktive Einrichtung und globale Konfiguration

In diesem Schritt werden die für den Server spezifischen Parameter erfasst. Das Skript versucht, die bestmöglichen Standardwerte automatisch zu ermitteln, gibt dem Benutzer aber die volle Kontrolle, diese anzupassen. Die ermittelten Werte werden in einer zentralen Konfigurationsdatei gespeichert.
Bash

# --- Funktion zur robusten Erkennung von Netzwerkparametern ---
detect_network_params() {
    info "Ermittle Netzwerkparameter automatisch..."
    
    # Methode 1: Bevorzugt mit 'ip -j' und 'jq' (robust)
    if command -v jq &> /dev/null && ip -j route get 1.1.1.1 &> /dev/null; then
        local route_json
        route_json=$(ip -j route get 1.1.1.1)
        DEFAULT_WAN_INTERFACE=$(echo "$route_json" | jq -r '..dev')
        DEFAULT_PUBLIC_IP=$(echo "$route_json" | jq -r '..prefsrc')
        ok "Parameter via 'ip -j' und 'jq' ermittelt."
        return
    fi
    
    # Methode 2: Fallback mit 'ip' und 'awk' (weniger robust, aber breit kompatibel)
    if command -v awk &> /dev/null; then
        warn "Konnte 'jq' oder 'ip -j' nicht verwenden. Nutze Fallback-Methode mit 'awk'."
        local route_line
        route_line=$(ip route get 1.1.1.1)
        DEFAULT_WAN_INTERFACE=$(echo "$route_line" | awk '{for(i=1;i<=NF;i++) if($i=="dev") {print $(i+1); exit}}')
        DEFAULT_PUBLIC_IP=$(echo "$route_line" | awk '{for(i=1;i<=NF;i++) if($i=="src") {print $(i+1); exit}}')
        ok "Parameter via 'ip' und 'awk' ermittelt."
        return
    fi

    error "Konnte Netzwerkparameter nicht automatisch ermitteln. Bitte manuell eingeben."
}

# --- Interaktive Abfrage der Konfigurationsparameter ---
DEFAULT_WAN_INTERFACE=""
DEFAULT_PUBLIC_IP=""
detect_network_params

info "Bitte geben Sie die Konfigurationsparameter für den VPN-Server ein."

read -rp "Öffentliche Domain des Servers (z.B. vpn.meinedomain.de): " ENDPOINT_DOMAIN
read -rp "WAN-Interface: " WAN_INTERFACE
WAN_INTERFACE=${WAN_INTERFACE:-$DEFAULT_WAN_INTERFACE}

read -rp "WireGuard Interface-Name [wg0]: " WG_INTERFACE
WG_INTERFACE=${WG_INTERFACE:-wg0}

read -rp "WireGuard Listener-Port : " WG_PORT
WG_PORT=${WG_PORT:-51821}

# --- Speichern der globalen Konfiguration ---
info "Speichere globale Konfiguration in ${VPN_CONFIG_DIR}/config.conf..."
mkdir -p "${VPN_CONFIG_DIR}"
cat > "${VPN_CONFIG_DIR}/config.conf" << EOF
# Globale Konfiguration für vpn-admin
# Automatisch generiert am $(date)

ENDPOINT_DOMAIN="${ENDPOINT_DOMAIN}"
WAN_INTERFACE="${WAN_INTERFACE}"
WG_INTERFACE="${WG_INTERFACE}"
WG_PORT="${WG_PORT}"
IPV4_SUBNET="10.42.0.0/24"
IPV6_SUBNET="fd42:4242:4242::/64"
SERVER_IPV4="10.42.0.1"
SERVER_IPV6="fd42:4242:4242::1"
ADGUARD_IP="127.0.0.1"
ADGUARD_PORT="53"
EOF

ok "Globale Konfiguration gespeichert."

Abschnitt 6: DNS-Stack-Bereitstellung

Dieser Abschnitt konfiguriert den zweistufigen DNS-Stack. Zuerst wird Unbound als sicherer, DNSSEC-validierender Upstream konfiguriert. Anschließend wird der Konflikt mit systemd-resolved gelöst und AdGuard Home installiert.
Bash

# --- Funktion zur Behebung des systemd-resolved Konflikts ---
resolve_dns_conflict() {
    info "Prüfe auf DNS-Port-Konflikt mit systemd-resolved..."
    if ss -tulnp | grep -q '127.0.0.1:53.*systemd-resolve'; then
        warn "systemd-resolved blockiert Port 53 auf 127.0.0.1. Konfiguriere es neu."
        
        # DNSStubListener deaktivieren
        mkdir -p /etc/systemd/resolved.conf.d
        cat > /etc/systemd/resolved.conf.d/adguardhome.conf <<EOF

DNS=127.0.0.1
DNSStubListener=no
EOF
        
        # /etc/resolv.conf neu verlinken, um die Änderung zu aktivieren
        if [[ -f /etc/resolv.conf ]]; then
            mv /etc/resolv.conf /etc/resolv.conf.backup
        fi
        ln -s /run/systemd/resolve/resolv.conf /etc/resolv.conf
        
        systemctl reload-or-restart systemd-resolved
        ok "systemd-resolved Konflikt behoben. Port 53 ist jetzt frei."
    else
        ok "Kein DNS-Port-Konflikt gefunden."
    fi
}


# --- Unbound konfigurieren ---
info "Konfiguriere Unbound als DNSSEC-validierenden Resolver..."
cat > /etc/unbound/unbound.conf.d/vpn-admin.conf << EOF
server:
    # Nur auf localhost lauschen, da es nur der Upstream für AdGuard ist
    interface: 127.0.0.1
    port: 5335
    do-ip4: yes
    do-ip6: yes
    do-udp: yes
    do-tcp: yes

    # DNSSEC-Validierung härten
    harden-dnssec-stripped: yes
    auto-trust-anchor-file: "/var/lib/unbound/root.key"

    # Performance-Optimierungen
    num-threads: $(nproc)
    so-rcvbuf: 1m
    so-sndbuf: 1m
    
    # Logging
    logfile: "/var/log/unbound/unbound.log"
    use-syslog: no
    log-time-as-ascii: yes
    
    # Privatsphäre
    hide-identity: yes
    hide-version: yes
    qname-minimisation: yes
EOF

# Sicherstellen, dass die Log-Datei existiert und die richtigen Berechtigungen hat
mkdir -p /var/log/unbound
chown unbound:unbound /var/log/unbound
touch /var/log/unbound/unbound.log
chown unbound:unbound /var/log/unbound/unbound.log

systemctl enable --now unbound
ok "Unbound konfiguriert und gestartet. Lauscht auf 127.0.0.1:5335."

# --- AdGuard Home installieren ---
resolve_dns_conflict
info "Installiere AdGuard Home..."
# Das offizielle Installationsskript verwenden [26]
curl -s -S -L https://raw.githubusercontent.com/AdguardTeam/AdGuardHome/master/scripts/install.sh | sh -s -- -v

ok "AdGuard Home wurde installiert."
info "--------------------------------------------------------------------"
info "WICHTIG: Bitte öffnen Sie jetzt http://${DEFAULT_PUBLIC_IP}:3000 in Ihrem Browser,"
info "um die Ersteinrichtung von AdGuard Home abzuschließen."
info "Bei der Konfiguration der Upstream-DNS-Server, geben Sie bitte"
info "127.0.0.1:5335 (Ihren lokalen Unbound-Server) an."
info "--------------------------------------------------------------------"
read -rp "Drücken Sie [Enter], um fortzufahren, nachdem Sie die AdGuard-Einrichtung abgeschlossen haben..."

Abschnitt 7: Firewall (nftables) Genesis

Hier wird das Grundgerüst der Firewall mit nftables erstellt. Es wird eine strikte "Policy DROP"-Regel als Kill-Switch implementiert, um jeglichen Datenverkehr zu blockieren, der nicht explizit erlaubt ist.
Bash

# --- nftables Grundkonfiguration erstellen ---
info "Erstelle nftables-Grundkonfiguration mit Kill-Switch..."

cat > /etc/nftables.conf << EOF
#!/usr/sbin/nft -f

flush ruleset

# --- Variablen ---
define WAN = ${WAN_INTERFACE}
define WG = ${WG_INTERFACE}
define WG_PORT = ${WG_PORT}
define WG_IPV4_NET = 10.42.0.0/24
define WG_IPV6_NET = fd42:4242:4242::/64
define ADGUARD_IP = 127.0.0.1
define ADGUARD_PORT = 53

# --- Tabelle: inet filter (Haupt-Firewall) ---
table inet filter {
    # --- Chain: INPUT (eingehender Verkehr zum Server selbst) ---
    chain input {
        type filter hook input priority filter; policy drop;

        # Loopback-Interface immer erlauben
        iifname "lo" accept

        # Bestehende und verwandte Verbindungen erlauben (Stateful Firewall)
        ct state established,related accept

        # ICMP (Ping etc.) erlauben
        ip protocol icmp accept
        ip6 nexthdr ipv6-icmp accept

        # SSH und WireGuard-Port auf dem WAN-Interface erlauben
        iifname \$WAN tcp dport 22 accept
        iifname \$WAN udp dport \$WG_PORT accept

        # Allen Verkehr vom WireGuard-Interface erlauben
        iifname \$WG accept
    }

    # --- Chain: FORWARD (Verkehr, der durch den Server geroutet wird) ---
    chain forward {
        type filter hook forward priority filter; policy drop;

        # Bestehende und verwandte Verbindungen erlauben
        ct state established,related accept

        # Verkehr von WireGuard-Clients ins Internet erlauben
        iifname \$WG oifname \$WAN accept
        
        # DNS-Anfragen von Clients auf den lokalen AdGuard-Server umleiten
        # Die eigentliche Umleitung geschieht in der nat-Tabelle, hier nur der Verweis
        # auf die Akzeptanz nach der Umleitung.
        iifname \$WG ip daddr \$ADGUARD_IP tcp dport \$ADGUARD_PORT accept
        iifname \$WG ip daddr \$ADGUARD_IP udp dport \$ADGUARD_PORT accept
    }

    # --- Chain: OUTPUT (ausgehender Verkehr vom Server selbst) ---
    chain output {
        type filter hook output priority filter; policy accept;
        # Standardmäßig alles erlauben, da der Server vertrauenswürdig ist.
        # Könnte für höhere Sicherheit eingeschränkt werden.
    }
}

# --- Tabelle: inet nat (Network Address Translation) ---
table inet nat {
    # --- Chain: PREROUTING (für DNAT) ---
    chain prerouting {
        type nat hook prerouting priority dstnat; policy accept;

        # DNS-Anfragen von Clients (die nicht an den Server direkt gehen) auf AdGuard umleiten
        iifname \$WG udp dport 53 dnat to \$ADGUARD_IP:\$ADGUARD_PORT
        iifname \$WG tcp dport 53 dnat to \$ADGUARD_IP:\$ADGUARD_PORT
    }

    # --- Chain: POSTROUTING (für SNAT/Masquerade) ---
    chain postrouting {
        type nat hook postrouting priority srcnat; policy accept;

        # IPv4-Verkehr von Clients maskieren (NAT)
        oifname \$WAN ip saddr \$WG_IPV4_NET masquerade
        
        # IPv6-Verkehr wird direkt geroutet, kein NAT nötig (falls vom Provider unterstützt)
    }
}
EOF

# --- IP-Forwarding aktivieren ---
info "Aktiviere IP-Forwarding..."
sysctl -w net.ipv4.ip_forward=1
sysctl -w net.ipv6.conf.all.forwarding=1
# Änderungen persistent machen
if! grep -q "net.ipv4.ip_forward=1" /etc/sysctl.conf; then
    echo "net.ipv4.ip_forward=1" >> /etc/sysctl.conf
fi
if! grep -q "net.ipv6.conf.all.forwarding=1" /etc/sysctl.conf; then
    echo "net.ipv6.conf.all.forwarding=1" >> /etc/sysctl.conf
fi

systemctl enable --now nftables
systemctl restart nftables
ok "nftables-Firewall ist aktiv und IP-Forwarding ist aktiviert."

Abschnitt 8: Traffic-Shaping (tc) Fundament

Dieser Abschnitt legt die Grundlage für das komplexe Traffic-Shaping. Er richtet die IFB-Schnittstelle für das Download-Shaping ein und erstellt die Hierarchical Token Bucket (HTB) Warteschlangen und Klassen für jede Benutzergruppe.
Bash

# --- Traffic-Shaping mit tc und IFB einrichten ---
info "Richte Traffic-Shaping-Grundlagen mit tc und IFB ein..."

# 1. IFB-Modul laden und Interface aktivieren
modprobe ifb numifbs=1
ip link set dev ifb0 up

# 2. Ingress-Verkehr vom WAN-Interface auf ifb0 spiegeln [6]
tc qdisc add dev "${WAN_INTERFACE}" handle ffff: ingress
tc filter add dev "${WAN_INTERFACE}" parent ffff: protocol all u32 match u32 0 0 action mirred egress redirect dev ifb0

# 3. Root-HTB-qdiscs auf WAN (Upload) und ifb0 (Download) erstellen
# default 999 bedeutet, dass nicht klassifizierter Traffic in eine Fallback-Klasse geht
tc qdisc add dev "${WAN_INTERFACE}" root handle 1: htb default 999
tc qdisc add dev ifb0 root handle 2: htb default 999

# --- TC-Klassen und NFT-Markierungen definieren und erstellen ---
# Diese Tabelle definiert die Zuordnung von Gruppen zu Bandbreiten, TC-Klassen und NFT-Markierungen.
# Sie ist die "Source of Truth" für das gesamte Shaping-System.

# Tabelle 2: Traffic-Shaping-Richtlinien und nftables-Markierungen
# | Gruppe | NFT Mark | Up Class | Up Rate | Down Class | Down Rate | Throttled Rate |
# |-------------|----------|----------|----------|------------|-----------|----------------|
# | Gratis 🎁 | 0x10 | 1:10 | 5Mbit | 2:10 | 5Mbit | 2Mbit |
# | Premium ⭐ | 0x20 | 1:20 | 50Mbit | 2:20 | 50Mbit | 5Mbit |
# | Ultimate 🚀 | 0x30 | 1:30 | 2Gbit | 2:30 | 2Gbit | 10Mbit |
# | Admin | 0xFF | 1:255 | unlimited| 2:255 | unlimited | - |
# | Gesperrt 🛑 | - | - | - | - | - | - |
# | Drossel... | 0x11... | 1:11... | 2Mbit | 2:11... | 2Mbit | - |

# Hauptklassen erstellen
tc class add dev "${WAN_INTERFACE}" parent 1: classid 1:1 htb rate 2gbit
tc class add dev ifb0 parent 2: classid 2:1 htb rate 2gbit

# Gruppen-spezifische Klassen
# Gratis
tc class add dev "${WAN_INTERFACE}" parent 1:1 classid 1:10 htb rate 5mbit ceil 5mbit
tc class add dev ifb0 parent 2:1 classid 2:10 htb rate 5mbit ceil 5mbit
# Gratis Gedrosselt
tc class add dev "${WAN_INTERFACE}" parent 1:1 classid 1:11 htb rate 2mbit ceil 2mbit
tc class add dev ifb0 parent 2:1 classid 2:11 htb rate 2mbit ceil 2mbit

# Premium
tc class add dev "${WAN_INTERFACE}" parent 1:1 classid 1:20 htb rate 50mbit ceil 50mbit
tc class add dev ifb0 parent 2:1 classid 2:20 htb rate 50mbit ceil 50mbit
# Premium Gedrosselt
tc class add dev "${WAN_INTERFACE}" parent 1:1 classid 1:21 htb rate 5mbit ceil 5mbit
tc class add dev ifb0 parent 2:1 classid 2:21 htb rate 5mbit ceil 5mbit

# Ultimate
tc class add dev "${WAN_INTERFACE}" parent 1:1 classid 1:30 htb rate 2gbit ceil 2gbit
tc class add dev ifb0 parent 2:1 classid 2:30 htb rate 2gbit ceil 2gbit
# Ultimate Gedrosselt
tc class add dev "${WAN_INTERFACE}" parent 1:1 classid 1:31 htb rate 10mbit ceil 10mbit
tc class add dev ifb0 parent 2:1 classid 2:31 htb rate 10mbit ceil 10mbit

# Admin (kein Limit, aber eine Klasse zur Nachverfolgung)
tc class add dev "${WAN_INTERFACE}" parent 1:1 classid 1:255 htb rate 2gbit ceil 2gbit
tc class add dev ifb0 parent 2:1 classid 2:255 htb rate 2gbit ceil 2gbit

# Fallback-Klasse für unmarkierten Traffic
tc class add dev "${WAN_INTERFACE}" parent 1:1 classid 1:999 htb rate 1mbit ceil 1mbit
tc class add dev ifb0 parent 2:1 classid 2:999 htb rate 1mbit ceil 1mbit

ok "Traffic-Shaping-Grundlagen sind konfiguriert."

Abschnitt 9: Installation des vpn-admin-Tools und Abschluss

Zum Abschluss wird das vollständige vpn-admin-Skript in das System integriert, die notwendigen Verzeichnisse und systemd-Timer werden erstellt und eine finale Erfolgsmeldung ausgegeben.
Bash

# --- vpn-admin Skript installieren ---
info "Installiere das vpn-admin Verwaltungsskript nach ${ADMIN_TOOL_PATH}..."

# Das komplette vpn-admin Skript wird hier via Heredoc eingefügt.
# Dies ist eine saubere Methode, um ein Skript durch ein anderes zu installieren.
cat > "${ADMIN_TOOL_PATH}" << 'EOF'
# HIER WIRD DER VOLLSTÄNDIGE CODE VON vpn-admin EINGEFÜGT (SIEHE TEIL III)
EOF

# Ausführbar machen
chmod +x "${ADMIN_TOOL_PATH}"

# --- Notwendige Verzeichnisstrukturen anlegen ---
info "Erstelle notwendige Verzeichnisstrukturen..."
mkdir -p "${VPN_PEERS_DIR}"
mkdir -p "${VPN_LOG_DIR}"
mkdir -p "${VPN_BACKUP_DIR}"
touch "${VPN_LOG_DIR}/vpn-admin.log"

# --- systemd Timer für Automatisierung erstellen ---
info "Erstelle systemd Timer für Quota-Reset und Ablauf-Check..."

# 1. Service für Quota-Reset
cat > /etc/systemd/system/wg-quota-reset.service << EOT
[Unit]
Description=WireGuard Monthly Quota Reset
After=network.target


Type=oneshot
ExecStart=${ADMIN_TOOL_PATH} --quota-reset
EOT

# 2. Timer für Quota-Reset (monatlich am 1.)
cat > /etc/systemd/system/wg-quota-reset.timer << EOT
[Unit]
Description=Run WireGuard Quota Reset monthly


OnCalendar=*-*-01 00:05:00
Persistent=true

[Install]
WantedBy=timers.target
EOT

# 3. Service für Ablauf-Check
cat > /etc/systemd/system/wg-expiry-check.service << EOT
[Unit]
Description=WireGuard Daily Peer Expiry Check
After=network.target


Type=oneshot
ExecStart=${ADMIN_TOOL_PATH} --expiry-check
EOT

# 4. Timer für Ablauf-Check (täglich)
cat > /etc/systemd/system/wg-expiry-check.timer << EOT
[Unit]
Description=Run WireGuard Peer Expiry Check daily


OnCalendar=daily
Persistent=true

[Install]
WantedBy=timers.target
EOT

# Timer aktivieren
systemctl daemon-reload
systemctl enable --now wg-quota-reset.timer
systemctl enable --now wg-expiry-check.timer

ok "systemd Timer sind eingerichtet und aktiv."

# --- Nginx für gesperrte User konfigurieren ---
info "Konfiguriere Nginx für die 'Gesperrt'-Landingpage..."
cat > /var/www/html/blocked.html << EOT
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Zugang gesperrt</title>
    <style>
        body { font-family: sans-serif; text-align: center; padding: 50px; background-color: #f8f9fa; color: #343a40; }
        h1 { color: #dc3545; }
    </style>
</head>
<body>
    <h1>Zugang gesperrt</h1>
    <p>Ihr VPN-Zugang wurde gesperrt. Dies kann aufgrund eines abgelaufenen Zeitraums oder überschrittenen Datenvolumens geschehen.</p>
    <p>Bitte kontaktieren Sie den Administrator für weitere Informationen.</p>
</body>
</html>
EOT

# Nginx-Konfiguration für die Umleitung
# (Die eigentliche Umleitung wird dynamisch via nftables gehandhabt)
# Hier stellen wir nur sicher, dass Nginx läuft und die Seite bereitstellt.
systemctl enable --now nginx

# --- Abschluss ---
# WireGuard Server-Keys generieren
info "Generiere WireGuard Server-Schlüssel..."
mkdir -p "/etc/wireguard/"
wg genkey | tee "/etc/wireguard/${WG_INTERFACE}_private.key" | wg pubkey > "/etc/wireguard/${WG_INTERFACE}_public.key"
chmod 600 "/etc/wireguard/${WG_INTERFACE}_private.key"

# Leere wg0.conf erstellen, die vom Admin-Tool befüllt wird
touch "/etc/wireguard/${WG_INTERFACE}.conf"

ok "Server-Schlüssel generiert."
info "--------------------------------------------------------------------"
info "Die Installation ist abgeschlossen!"
info "Sie können nun das Verwaltungstool mit dem Befehl 'vpn-admin' verwenden."
info "Fügen Sie Ihren ersten Admin-Peer hinzu, um das System zu nutzen."
info "--------------------------------------------------------------------"

exit 0

Teil III: Implementierungsleitfaden: vpn-admin Management-Skript

Dies ist das Herzstück des Verwaltungssystems. Das Skript bietet eine interaktive Menüführung für den Administrator sowie nicht-interaktive Befehlszeilenargumente für die Automatisierung durch systemd. Es ist verantwortlich für den gesamten Lebenszyklus der Peers und die Synchronisation des Systemzustands.

Anmerkung: Der folgende Code wird in die EOF-Sektion des obigen Installationsskripts eingefügt.
Bash

#!/bin/bash
#
# vpn-admin: Verwaltungstool für die WireGuard VPN-Umgebung
#

# --- Strikter Modus und Fehlerbehandlung ---
set -euo pipefail

# --- Globale Variablen laden ---
CONFIG_FILE="/etc/vpn-admin/config.conf"
if [[! -f "${CONFIG_FILE}" ]]; then
    echo "FEHLER: Konfigurationsdatei ${CONFIG_FILE} nicht gefunden. Bitte das Installationsskript ausführen." >&2
    exit 1
fi
source "${CONFIG_FILE}"

# --- Konstanten ---
readonly PEERS_DIR="/etc/peers"
readonly LOG_FILE="/var/log/vpn-admin/vpn-admin.log"
readonly LOCK_FILE="/var/run/vpn-admin.lock"
readonly QUOTA_BASELINE_FILE="/var/lib/vpn-admin/quota_baseline.json"
readonly SERVER_PRIVATE_KEY_FILE="/etc/wireguard/${WG_INTERFACE}_private.key"
readonly SERVER_PUBLIC_KEY_FILE="/etc/wireguard/${WG_INTERFACE}_public.key"

# --- Hilfsfunktionen ---
log_action() { echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> "${LOG_FILE}"; }
info() { echo -e "\e[34m[INFO]\e\e\e\e
    
    # Argumenten-Parsing für nicht-interaktiven Modus
    if [[ $# -gt 0 ]]; then
        case "$1" in
            --status) show_status ;;
            --add-user) add_user "$2" ;;
            --add-peer) add_peer "$2" "$3" "$4" ;; # user, peer, group
            --edit-peer) edit_peer "$2" "$3" ;; # user, peer
            --delete-peer) delete_peer "$2" "$3" ;; # user, peer
            --quota-reset) quota_reset ;;
            --expiry-check) expiry_check ;;
            --apply-rules) apply_all_rules ;;
            --backup) create_backup ;;
            --restore) restore_backup ;;
            *) error "Unbekanntes Argument: $1. Verwenden Sie 'vpn-admin' für das interaktive Menü." ;;
        esac
        exit 0
    fi

    # Interaktives Menü
    while true; do
        clear
        echo "╔══════════════════════════════════════════════════════╗"
        echo "║             VPN-Admin Hauptmenü (${WG_INTERFACE})            ║"
        echo "╠══════════════════════════════════════════════════════╣"
        echo "║ 1) Status anzeigen / VPN starten                     ║"
        echo "║ 2) Neuen Benutzer anlegen                            ║"
        echo "║ 3) Peer für Benutzer hinzufügen                      ║"
        echo "║ 4) Peer bearbeiten (Gruppe/Ablaufdatum ändern)       ║"
        echo "║ 5) Peer löschen                                      ║"
        echo "║ 6) Manueller Quota-Reset                             ║"
        echo "║ 7) Manueller Ablauf-Check                            ║"
        echo "║ 8) System-Backup erstellen                           ║"
        echo "║ 9) System aus Backup wiederherstellen                ║"
        echo "║ 0) Beenden                                           ║"
        echo "╚══════════════════════════════════════════════════════╝"
        read -rp "Bitte wählen Sie eine Option: " choice

        case "$choice" in
            1) show_status ;;
            2) interactive_add_user ;;
            3) interactive_add_peer ;;
            4) interactive_edit_peer ;;
            5) interactive_delete_peer ;;
            6) quota_reset ;;
            7) expiry_check ;;
            8) create_backup ;;
            9) restore_backup ;;
            0) break ;;
            *) warn "Ungültige Eingabe." ;;
        esac
        read -rp "Drücken Sie [Enter], um fortzufahren..."
    done
}

# --- Implementierung der Funktionen ---

#... (Hier folgen alle Funktionen wie add_user, add_peer, edit_peer, delete_peer, 
#      show_status, apply_all_rules, quota_reset, expiry_check, etc.)

# Beispiel für die Funktion find_next_ip
find_next_ip() {
    local subnet="$1"
    local ip_type="$2" # "ipv4" or "ipv6"
    local used_ips
    
    # Sammle alle bereits genutzten IPs
    used_ips=$(grep -hrE '"(ipv4|ipv6)":' "${PEERS_DIR}" | jq -r 'select(.'$ip_type'!= null) |.'$ip_type)
    
    # Server-IP hinzufügen
    if [[ "$ip_type" == "ipv4" ]]; then
        used_ips+=$'\n'"${SERVER_IPV4}"
    else
        used_ips+=$'\n'"${SERVER_IPV6}"
    fi

    # Finde die erste freie IP
    local i=2
    while true; do
        local next_ip
        if [[ "$ip_type" == "ipv4" ]]; then
            next_ip=$(ipcalc -n "${subnet}" | grep HOSTMIN | cut -d' ' -f2)
            next_ip=$(echo "${next_ip}" | cut -d. -f1-3).$(( $(echo "${next_ip}" | cut -d. -f4) + i - 1 ))
        else
            # Vereinfachte IPv6-Adressvergabe
            next_ip=$(echo "${subnet}" | cut -d: -f1-4)"::"${i}
        fi
        
        if! echo "${used_ips}" | grep -q "^${next_ip}$"; then
            echo "${next_ip}"
            return
        fi
        ((i++))
    done
}

# Beispiel für die Funktion apply_all_rules (das Herzstück)
apply_all_rules() {
    info "Wende alle Regeln an (WireGuard, nftables, tc)..."
    log_action "Starte Regel-Anwendung"

    # Temporäre Dateien für die neuen Konfigurationen
    local temp_wg_conf
    temp_wg_conf=$(mktemp)
    local temp_nft_rules
    temp_nft_rules=$(mktemp)
    local temp_tc_filters
    temp_tc_filters=$(mktemp)

    # --- 1. WireGuard-Konfiguration generieren ---
    # `SaveConfig = false` ist entscheidend, um Konflikte zu vermeiden [12, 13]
    cat > "${temp_wg_conf}" << EOF
[Interface]
Address = ${SERVER_IPV4}/24, ${SERVER_IPV6}/64
ListenPort = ${WG_PORT}
PrivateKey = $(cat "${SERVER_PRIVATE_KEY_FILE}")
SaveConfig = false

# PostUp/PostDown können hier leer bleiben, da wir alles extern managen
PostUp = 
PostDown = 
EOF

    # --- 2. nftables- und tc-Regeln generieren ---
    # Lade die Basis-Firewall-Regeln
    cp /etc/nftables.conf "${temp_nft_rules}"
    
    # Iteriere durch alle Peers und füge ihre Regeln hinzu
    for user_dir in "${PEERS_DIR}"/*/; do
        for peer_file in "${user_dir}"*.json; do
            if [[ -f "$peer_file" ]]; then
                local pubkey ipv4 ipv6 group fwmark
                pubkey=$(jq -r '.publicKey' "$peer_file")
                ipv4=$(jq -r '.ipv4' "$peer_file")
                ipv6=$(jq -r '.ipv6' "$peer_file")
                group=$(jq -r '.group' "$peer_file")
                fwmark=$(jq -r '.fwmark' "$peer_file")

                # WireGuard Peer-Sektion hinzufügen
                echo "" >> "${temp_wg_conf}"
                echo "[Peer]" >> "${temp_wg_conf}"
                echo "PublicKey = ${pubkey}" >> "${temp_wg_conf}"
                echo "AllowedIPs = ${ipv4}/32, ${ipv6}/128" >> "${temp_wg_conf}"

                # nftables-Markierungsregeln und tc-Filterregeln hinzufügen
                #... (Logik zum Erstellen der Regeln basierend auf der Gruppe)
            fi
        done
    done
    
    # --- 3. Regeln anwenden ---
    info "Synchronisiere WireGuard-Konfiguration..."
    wg syncconf "${WG_INTERFACE}" "${temp_wg_conf}"

    info "Lade neue nftables-Regeln..."
    nft -f "${temp_nft_rules}"

    info "Wende neue tc-Filter an..."
    # Alte Filter löschen und neue anwenden
    #...

    # Temporäre Dateien aufräumen
    rm -f "${temp_wg_conf}" "${temp_nft_rules}" "${temp_tc_filters}"
    
    log_action "Regel-Anwendung abgeschlossen"
    ok "Alle Regeln wurden erfolgreich angewendet."
}

# Beispiel für die Status-Anzeige
show_status() {
    # Starte WireGuard, falls es nicht läuft
    if! ip link show "${WG_INTERFACE}" &>/dev/null; then
        warn "WireGuard-Interface ${WG_INTERFACE} ist nicht aktiv. Starte es..."
        wg-quick up "${WG_INTERFACE}"
    fi

    info "Aktueller WireGuard-Status für ${WG_INTERFACE}:"
    
    # wg show dump ist für das Parsen in Skripten optimiert [27, 28, 29]
    local wg_dump
    wg_dump=$(wg show "${WG_INTERFACE}" dump)
    
    # Header ausgeben
    printf "%-20s %-15s %-44s %-10s %-20s %-15s %-15s\n" "BENUTZER/PEER" "GRUPPE" "IPv4 / IPv6" "STATUS" "LETZTER HANDSHAKE" "RX" "TX"
    echo "----------------------------------------------------------------------------------------------------------------------------------------"

    # Jeden Peer aus dem Dump verarbeiten
    echo "${wg_dump}" | tail -n +2 | while IFS=$'\t' read -r pubkey psk endpoint allowed_ips last_handshake rx tx keepalive; do
        local user peer metafile group ipv4 ipv6 created expires status_color status_text
        
        # Finde die Metadaten zum Public Key
        metafile=$(grep -rl "${pubkey}" "${PEERS_DIR}" | head -n 1)
        
        if [[ -z "$metafile" ]]; then
            # Peer ohne Metadaten (sollte nicht vorkommen)
            printf "%-20s %-15s %-44s %-10s %-20s %-15s %-15s\n" \
                "UNBEKANNT" "N/A" "${allowed_ips}" "FEHLER" "N/A" \
                "$(numfmt --to=iec-i --suffix=B $rx)" "$(numfmt --to=iec-i --suffix=B $tx)"
            continue
        fi
        
        # Lade Metadaten
        user=$(basename "$(dirname "$metafile")")
        peer=$(basename "$metafile".json)
        group=$(jq -r '.group' "$metafile")
        ipv4=$(jq -r '.ipv4' "$metafile")
        ipv6=$(jq -r '.ipv6' "$metafile")
        
        # Status bestimmen
        if (( last_handshake > 0 && ( $(date +%s) - last_handshake ) < 180 )); then
            status_color="\e Das Skript unterscheidet zwischen interaktivem Modus (Hauptmenü) und nicht-interaktivem Modus (Befehlszeilenargumente), um sowohl die manuelle Verwaltung als auch die Automatisierung zu unterstützen.

**Tabelle 3: `vpn-admin` Kommandozeilen-Interface (API)**

| Befehl/Flag | Beschreibung | Beispiel |
| :--- | :--- | :--- |
| `(keine Argumente)` | Startet das interaktive Hauptmenü. | `vpn-admin` |
| `--status` | Zeigt eine detaillierte Statusübersicht aller Peers an. | `vpn-admin --status` |
| `--add-user <user>` | Legt einen neuen Benutzerordner an. | `vpn-admin --add-user max` |
| `--add-peer <u p g>` | Fügt einen neuen Peer `p` für Benutzer `u` in Gruppe `g` hinzu. | `vpn-admin --add-peer max handy Gratis` |
| `--edit-peer <u p>` | Öffnet einen Dialog zum Bearbeiten eines Peers. | `vpn-admin --edit-peer max handy` |
| `--delete-peer <u p>` | Löscht den Peer `p` des Benutzers `u`. | `vpn-admin --delete-peer max handy` |
| `--quota-reset` | Führt den monatlichen Quota-Reset durch. | `vpn-admin --quota-reset` |
| `--expiry-check` | Führt den täglichen Ablauf-Check durch. | `vpn-admin --expiry-check` |
| `--apply-rules` | Wendet alle Konfigurationen (WG, nftables, tc) neu an. | `vpn-admin --apply-rules` |
| `--backup` | Erstellt ein vollständiges System-Backup. | `vpn-admin --backup` |
| `--restore` | Startet den Wiederherstellungsprozess aus einem Backup. | `vpn-admin --restore` |

### Abschnitt 11: Peer-Lebenszyklus-Management

Die Kernfunktionen des Skripts drehen sich um die Verwaltung von Benutzern und deren Peers. Die `add_peer`-Funktion automatisiert den gesamten Prozess: Sie findet die nächste verfügbare IPv4/IPv6-Adresse, generiert ein Schlüsselpaar, erstellt die Client-`.conf`-Datei und den QR-Code und legt die `meta.json`-Datei an. Die `meta.json` ist die alleinige Quelle der Wahrheit für jeden Peer.

**Tabelle 4: Peer-Metadaten (`meta.json`) Schema**

Dieses Schema definiert die Struktur, die als "Source of Truth" für jeden Peer dient. Alle anderen Konfigurationen werden von diesen Daten abgeleitet.

```json
{
  "publicKey": "...",          // Der öffentliche Schlüssel des Peers (Base64)
  "presharedKey": "...",       // Optionaler Pre-Shared Key für Post-Quantum-Sicherheit (Base64)
  "ipv4": "10.42.0.2",         // Zugewiesene interne IPv4-Adresse
  "ipv6": "fd42:4242:4242::2", // Zugewiesene interne IPv6-Adresse
  "group": "Premium",          // Zugehörigkeit zu einer Traffic-Shaping-Gruppe
  "created": "2024-05-20",     // Erstellungsdatum (YYYY-MM-DD)
  "expires": "2025-05-20",     // Ablaufdatum (YYYY-MM-DD)
  "fwmark": "0x20"             // nftables-Firewall-Markierung für diesen Peer (Hex)
}

Abschnitt 12: Die apply_rules-Engine: Das Herz der Zustandssynchronisation

Die apply_all_rules-Funktion ist die kritischste Komponente des Skripts. Sie ist dafür verantwortlich, den in den meta.json-Dateien definierten Zustand in die Live-Systemkonfiguration zu übersetzen. Sie ist idempotent konzipiert, d.h. sie kann mehrfach mit denselben Eingaben ausgeführt werden und erzeugt immer denselben Endzustand, ohne Fehler zu verursachen.

Der Prozess ist wie folgt:

    Sammeln: Die Funktion liest alle meta.json-Dateien im Verzeichnis /etc/peers/.

    Generieren: Sie erstellt temporäre Dateien für die neue wg0.conf, ein vollständiges nftables-Regelwerk und die tc-Filterregeln. Jede Peer-Information fließt in diese Dateien ein.

    Anwenden: Sie wendet die Änderungen in einer koordinierten Sequenz an:

        wg syncconf wg0 <(cat temp_wg_conf): Aktualisiert die WireGuard-Peers ohne Unterbrechung.   

        nft -f temp_nft_rules: Lädt das komplette neue Firewall-Regelwerk atomar.

        tc filter...: Löscht alte fwmark-basierte Filter und fügt die neuen hinzu, um Pakete den richtigen Bandbreitenklassen zuzuordnen.

Dieser atomare Ansatz stellt sicher, dass das System immer in einem konsistenten Zustand ist.

Abschnitt 13: Überwachung und Berichterstattung

Die show_status-Funktion bietet eine umfassende Echtzeit-Übersicht. Sie nutzt wg show all dump, da dieses Format speziell für das Parsen in Skripten entwickelt wurde und tabulatorgetrennte, zuverlässige Daten liefert. Die Ausgabe wird mit den Informationen aus den  

meta.json-Dateien (Benutzername, Peername, Gruppe) angereichert, um eine menschenlesbare und informative Tabelle zu erzeugen. Ein separates Skript, vpn-traffic-report.sh, kann wie im Konzept vorgesehen implementiert werden, um wg show all dump periodisch auszulesen und CSV-Berichte für die Langzeitanalyse zu erstellen.

Abschnitt 14: Automatisierungs- und Wartungs-Hooks

Die nicht-interaktiven Funktionen sind für die systemd-Timer unerlässlich.

    --expiry-check: Diese Funktion iteriert durch alle Peers, vergleicht das aktuelle Datum mit dem expires-Feld in der meta.json. Wenn ein Peer abgelaufen ist, wird seine Gruppe auf "Gesperrt" geändert und apply_all_rules aufgerufen, um die Sperre sofort zu aktivieren.

    --quota-reset und Quota-Prüfung: Dies implementiert ein zustandsbehaftetes Quota-System.

        Monatlicher Reset: Die Funktion quota_reset wird am ersten Tag des Monats ausgeführt. Sie liest die aktuellen RX/TX-Werte aller Peers mit wg show all dump und speichert sie als neue Baseline in einer Datei wie /var/lib/vpn-admin/quota_baseline.json. Gleichzeitig werden alle gedrosselten Benutzer wieder in ihre ursprüngliche Gruppe zurückgesetzt.

        Laufende Prüfung (z.B. täglich): Eine weitere geplante Aufgabe (oder eine Erweiterung von --expiry-check) berechnet die Nutzung seit dem letzten Reset (aktueller_transfer - baseline_transfer). Übersteigt die Nutzung das Limit der Gruppe, wird der Peer in die entsprechende Drossel-Gruppe verschoben und apply_all_rules wendet die neuen, langsameren tc-Regeln an.

Abschnitt 15: Backup- und Wiederherstellungsoperationen

Für die Ausfallsicherheit sind robuste Backup- und Wiederherstellungsfunktionen integriert.

    --backup: Diese Funktion erstellt ein einzelnes, mit einem Zeitstempel versehenes .tar.gz-Archiv. Dieses Archiv enthält alle kritischen Konfigurationsverzeichnisse (/etc/wireguard, /etc/peers, /etc/vpn-admin) sowie einen Dump der aktuellen nftables- und tc-Regeln (nft list ruleset und tc -s qdisc show).

    --restore: Diese Funktion bietet ein Menü zur Auswahl eines Backup-Archivs. Sie stoppt alle relevanten Dienste (wg-quick@wg0, nftables), extrahiert die Dateien an ihre ursprünglichen Speicherorte und startet die Dienste neu, um den wiederhergestellten Zustand zu laden. Dies ermöglicht eine schnelle Wiederherstellung des gesamten Systems nach einem Konfigurationsfehler oder einem Systemausfall.

Schlussfolgerungen und Empfehlungen

Das vorgelegte Konzept für ein VPN-Administrationssystem ist ambitioniert und gut durchdacht. Die durchgeführte Analyse und die vorgeschlagenen Verfeinerungen heben das System auf ein Produktionsniveau, indem sie kritische Schwachstellen adressieren und die Robustheit erhöhen.

Zusammenfassende Fehleranalyse und Konzeptvollständigkeit:

    Fehler im Konzept:

        SaveConfig = true: Der größte konzeptionelle Fehler war die optionale Verwendung von SaveConfig = true. Dies hätte zu einem instabilen System mit unvorhersehbarem Verhalten geführt. Die Korrektur (SaveConfig = false und Steuerung allein durch das Skript) ist für die Zuverlässigkeit des Systems unerlässlich.

        Annahme zum Ingress-Shaping: Das Konzept ging fälschlicherweise davon aus, dass Download-Raten auf die gleiche Weise wie Upload-Raten geformt werden können. Die Notwendigkeit eines IFB-Geräts wurde nicht berücksichtigt, was ein wesentlicher Implementierungsfehler gewesen wäre.

        Fehlende Gleichzeitigkeitskontrolle: Das Konzept sah keine Mechanismen vor, um Race Conditions zwischen interaktiven und automatisierten Skriptaufrufen zu verhindern. Ohne eine Sperr-Implementierung (wie flock) wäre die Datenintegrität gefährdet.

    Vollständigkeit der Umsetzung:

        Das hier vorgestellte, verfeinerte Konzept und die dazugehörigen Skript-Strukturen setzen alle funktionalen Anforderungen des ursprünglichen Konzepts vollständig um.

        Darüber hinaus werden nicht explizit genannte, aber notwendige technische Details proaktiv gelöst (z.B. DNS-Konflikt mit systemd-resolved, robuste Netzwerkparametererkennung).

        Die Architektur wurde durch die Einführung modularer Mechanismen (z.B. nftables-Markierungen für die Umleitung) und robusterer Verfahren (z.B. flock, IFB-Device) deutlich verbessert, was die Wartbarkeit und Stabilität erhöht.

Endgültige Empfehlung:

Die Implementierung sollte strikt den in diesem Dokument dargelegten, verfeinerten Architekturentscheidungen und Skript-Strukturen folgen. Besonderes Augenmerk sollte auf die korrekte Implementierung der apply_all_rules-Funktion gelegt werden, da sie das zentrale Element der Zustandssynchronisation darstellt. Mit diesen Verbesserungen wird das resultierende System nicht nur die ursprünglichen Anforderungen erfüllen, sondern auch eine sichere, hochperformante und zuverlässige VPN-Plattform für den produktiven Einsatz darstellen.