Expertenanalyse und Implementierungsleitfaden f√ºr ein VPN-Administrationssystem auf Debian 12

Dieses Dokument stellt eine umfassende technische Analyse und einen Implementierungsleitfaden f√ºr ein fortschrittliches WireGuard VPN-Administrationssystem auf Debian 12 (Bookworm) dar. Es richtet sich an erfahrene Systemadministratoren und Netzwerkingenieure. Das Dokument gliedert sich in drei Hauptteile:

    Strategische √úberpr√ºfung und Architekturoptimierung: Eine detaillierte Analyse des urspr√ºnglichen Konzepts, Identifizierung potenzieller Schwachstellen und Vorstellung von architektonischen Verbesserungen f√ºr mehr Stabilit√§t, Sicherheit und Leistung.

    Implementierungsleitfaden vpn-installer.sh: Der vollst√§ndig kommentierte Quellcode und die Erl√§uterung des Installationsskripts, das die gesamte Serverumgebung automatisiert einrichtet.

    Implementierungsleitfaden vpn-admin: Der vollst√§ndig kommentierte Quellcode und die Erl√§uterung des Verwaltungswerkzeugs f√ºr den gesamten Lebenszyklus von Benutzern und Peers.

Teil I: Strategische √úberpr√ºfung und Architekturoptimierung

Dieser Teil dient als formale √úberpr√ºfung des vorgelegten Konzepts. Er geht √ºber eine einfache Fehlerpr√ºfung hinaus und bietet strategische Empfehlungen, um sicherzustellen, dass die endg√ºltige Implementierung robust, sicher und wartbar ist. Potenzielle Konflikte und nicht explizit genannte Komplexit√§ten werden identifiziert und gel√∂st.

Abschnitt 1: Validierung der Kernarchitektur

Die vorgeschlagene Architektur bildet eine solide Grundlage f√ºr ein leistungsf√§higes und modernes VPN-Gateway.

1.1 Komponentensynergie und Begr√ºndung

Die Auswahl der Kerntechnologien ist strategisch fundiert. Die Kombination aus WireGuard f√ºr den VPN-Transport, nftables f√ºr die zustandsbehaftete Paketfilterung, tc f√ºr das Traffic-Shaping und einem zweistufigen DNS-Stack mit Unbound und AdGuard Home stellt eine erstklassige, moderne Architektur dar. Jede Komponente ist hochleistungsf√§hig und l√§sst sich gut mit den anderen integrieren, vorausgesetzt, die Schnittstellen werden sorgf√§ltig verwaltet. WireGuard bietet eine schlanke und performante VPN-Grundlage, w√§hrend nftables als dessen moderner Nachfolger iptables √ºberlegen ist und eine klarere Syntax bietet. AdGuard Home erm√∂glicht eine netzwerkweite Filterung von Werbung und Trackern, was einen erheblichen Mehrwert darstellt.  

1.2 Identifizierung kritischer Interaktionspunkte

Die wahre Komplexit√§t dieses Projekts liegt nicht in den einzelnen Komponenten, sondern in ihrer Interaktion. Zwei Bereiche sind hierbei von entscheidender Bedeutung:

    Zustandssynchronisation: Die gr√∂√üte Herausforderung besteht darin, sicherzustellen, dass der vom vpn-admin-Skript verwaltete Zustand (gespeichert in /etc/peers/) jederzeit perfekt mit dem laufenden Zustand von WireGuard, nftables und tc synchronisiert ist. Ein Fehler in dieser Synchronisation k√∂nnte zu Sicherheitsl√ºcken (z.B. ein Peer wird nicht korrekt blockiert) oder zu Funktionsst√∂rungen (z.B. falsche Bandbreitenlimits) f√ºhren.

    Logik des Paketflusses: Das System manipuliert Pakete auf mehreren Ebenen des Netzwerkstacks: WireGuard-Verschl√ºsselung, nftables-Markierung und NAT, sowie tc-Klassifizierung und -Shaping. Ein klares und pr√§zises Verst√§ndnis der Reise eines Pakets durch den Linux-Kernel ist unerl√§sslich, damit die Regeln korrekt und in der richtigen Reihenfolge angewendet werden. Beispielsweise muss die Markierung eines Pakets in nftables erfolgen, bevor tc diese Markierung zur Klassifizierung verwenden kann.   

Um die Verantwortlichkeiten klar zu definieren und Mehrdeutigkeiten zu vermeiden, fasst die folgende Tabelle die Rolle jeder Komponente zusammen.

Komponente
	

Rolle in der Architektur
	

Begr√ºndung & Hauptmerkmale

WireGuard
	

Sicherer VPN-Tunnel-Transport
	

Hohe Performance, moderne Kryptographie, schlanke Codebasis. Bildet das Kernst√ºck des VPN-Dienstes.  

nftables
	

Firewall, NAT, Paketmarkierung
	

Moderner Paketfilter f√ºr Linux. Implementiert den Kill-Switch, NAT f√ºr den Internetzugang der Clients und markiert Pakete zur Weiterverarbeitung durch tc.  

tc (HTB)
	

Egress Traffic-Shaping (Upload)
	

Hierarchical Token Bucket (HTB) erm√∂glicht die Erstellung von Bandbreitenklassen f√ºr verschiedene Benutzergruppen (Upload-Raten).  

ifb-Modul
	

Ingress Traffic-Shaping (Download)
	

Das Intermediate Functional Block (IFB) Device ist notwendig, um ankommenden Verkehr (Download) umzuleiten und ihn als ausgehenden Verkehr zu behandeln, was echtes Shaping erm√∂glicht.  

Unbound
	

DNSSEC-validierender rekursiver DNS-Resolver
	

Dient als sicherer Upstream-Resolver ausschlie√ülich f√ºr AdGuard Home. Stellt die Integrit√§t von DNS-Antworten durch DNSSEC-Validierung sicher.

AdGuard Home
	

Filternder DNS-Server & DHCP (optional)
	

Blockiert Werbung und Tracker f√ºr alle VPN-Clients. Nutzt Unbound als vertrauensw√ºrdige Quelle. Bietet eine Web-Oberfl√§che zur Verwaltung.  

jq
	

JSON-Prozessor
	

Unerl√§sslich f√ºr das zuverl√§ssige Parsen und Bearbeiten der meta.json-Dateien der Peers in den Bash-Skripten.  

qrencode
	

QR-Code-Generator
	

Erstellt QR-Codes aus den Client-Konfigurationsdateien f√ºr eine einfache Einrichtung auf mobilen Ger√§ten.  

systemd
	

Service- & Timer-Management
	

Stellt die Persistenz der Dienste sicher (WireGuard, nftables etc.) und f√ºhrt automatisierte Wartungsaufgaben (Quota-Reset, Ablauf-Check) √ºber Timer aus.  

Abschnitt 2: Kritische Implementierungsentscheidungen & Optimierungen

Dieser Abschnitt befasst sich mit spezifischen, hochwirksamen technischen Entscheidungen, die im Konzept entweder mehrdeutig sind oder einen robusteren Ansatz erfordern.

2.1 WireGuard-Konfigurationsmanagement: Das SaveConfig-Dilemma

Das Konzept listet SaveConfig = true als optionale Einstellung in der wg0.conf. Eine Analyse der Funktionsweise von wg-quick zeigt, dass diese Option in direktem Konflikt mit einem externen Verwaltungsskript steht.  

SaveConfig=true weist wg-quick an, beim Herunterfahren des Interfaces den aktuellen Live-Zustand in die Konfigurationsdatei zur√ºckzuschreiben. Dies w√ºrde die deterministisch aus den Metadaten generierte Konfiguration unseres vpn-admin-Skripts √ºberschreiben und zerst√∂ren.  

Dies ist keine blo√üe Konfigurationsentscheidung, sondern eine grundlegende Festlegung √ºber die "Quelle der Wahrheit" (Source of Truth) des Systems. Die Aktivierung von SaveConfig=true w√ºrde zwei konkurrierende Autorit√§ten f√ºr den Zustand des VPN schaffen: das vpn-admin-Skript und den wg-quick-Dienst selbst. Dies f√ºhrt zu einem instabilen, unvorhersehbaren System, in dem √Ñnderungen stillschweigend r√ºckg√§ngig gemacht werden oder verloren gehen k√∂nnen. Ein robustes System muss einen einzigen, unidirektionalen Kontrollfluss haben. Das vpn-admin-Skript muss die alleinige Autorit√§t √ºber die Konfiguration sein.

Empfehlung: Die Implementierung wird SaveConfig = false fest kodieren. Das vpn-admin-Skript ist allein verantwortlich f√ºr die Erstellung der vollst√§ndigen wg0.conf aus den Peer-Metadaten. √Ñnderungen werden atomar und ohne Unterbrechung aktiver Sitzungen mittels wg syncconf wg0 <(wg-quick strip wg0) angewendet. Dieser Befehl synchronisiert die Live-Konfiguration mit einer neuen Konfiguration, die aus der alten "gestrippt" und mit neuen Peer-Informationen angereichert wird, ohne das Interface neu zu starten.  

2.2 Ingress (Download) Traffic-Shaping: Der IFB-Imperativ

Die Anforderung im Konzept, gestaffelte Download-Geschwindigkeitsbegrenzungen durchzusetzen, ist ein Kernmerkmal. Es wird jedoch eine entscheidende technische Einschr√§nkung des Traffic-Control-Subsystems von Linux √ºbersehen. Standard-ingress-qdiscs k√∂nnen nur "Policing" durchf√ºhren, d.h. Pakete, die eine bestimmte Rate √ºberschreiten, werden verworfen. Dies f√ºhrt bei TCP-basierten Protokollen zu einer schlechten Performance durch wiederholte Retransmissions. Echtes "Shaping", bei dem Pakete zur Gl√§ttung von Bursts in eine Warteschlange gestellt und verz√∂gert werden, ist nur f√ºr ausgehenden (Egress) Verkehr verf√ºgbar.  

Die Recherche zeigt unmissverst√§ndlich, dass zur Erreichung des Ziels ein Intermediate Functional Block (IFB) Device zwingend erforderlich ist. Dies ist eine nicht offensichtliche, aber wesentliche Komponente. Der gesamte ankommende Verkehr von der WAN-Schnittstelle muss auf eine virtuelle  

ifb0-Schnittstelle gespiegelt werden. Dort kann er dann als ausgehender Verkehr behandelt und mit der HTB-qdisc ordnungsgem√§√ü geformt werden. Das IFB-Device ist somit eine zwingende, bisher nicht genannte Abh√§ngigkeit, damit das Konzept des Benutzers realisiert werden kann.

Empfehlung: Das vpn-installer.sh-Skript wird die IFB-Infrastruktur transparent einrichten. Dies beinhaltet das Laden des ifb-Kernelmoduls, das Erstellen des ifb0-Ger√§ts und das Hinzuf√ºgen des notwendigen tc filter auf der WAN-Schnittstelle, um den gesamten Ingress-Verkehr auf ifb0 umzuleiten. Die apply_rules-Funktion des vpn-admin-Skripts wird dann so konzipiert, dass sie zwei S√§tze von tc-Klassen und -Filtern verwaltet: einen auf der WAN-Schnittstelle f√ºr das Upload-Shaping und einen auf der ifb0-Schnittstelle f√ºr das Download-Shaping.

2.3 Firewall-Strategie zur Umleitung blockierter Peers

Das Konzept, "Gesperrte" Peers auf eine Landing-Page umzuleiten, ist mit nftables realisierbar. Eine einfache dnat-Regel ist jedoch nicht ausreichend, insbesondere wenn man eine saubere und skalierbare L√∂sung anstrebt. Die Implementierung erfordert einen mehrstufigen Prozess innerhalb des nftables-Regelwerks, der das im Konzept bereits angedachte Prinzip der gruppenbasierten Markierung nutzt.

Der Prozess sieht wie folgt aus:

    Ein Peer wird in seiner meta.json als "Gesperrt" markiert.

    Die apply_rules-Funktion liest diesen Status.

    Sie generiert eine nftables-Regel in der prerouting-Chain der nat-Tabelle, die Pakete anhand der Quell-IP-Adresse des Peers (ip saddr 10.42.0.X) identifiziert und eine eindeutige Firewall-Markierung setzt (z. B. meta mark set 0xBLOCKED).

    Ein separater, hochpriot√§rer Satz von Regeln in der prerouting-Chain reagiert dann auf diese 0xBLOCKED-Markierung f√ºr Verkehr auf den Ports 80 (HTTP) und 443 (HTTPS) und wendet ein dnat an, um ihn zu einem lokalen Webserver umzuleiten.   

Diese Entkopplung von Peer-Identifikation und Umleitungsaktion macht das Regelwerk sauberer, modularer und leichter wartbar. F√ºr die HTTPS-Umleitung ist zu beachten, dass der Server die SSL-Verbindung f√ºr beliebige Domains nicht terminieren kann. Der praktischste Ansatz ist die Umleitung auf eine dedizierte HTTP/S-Landingpage, die vom Administrator gehostet wird und deren Zertifikat auf dem Server vorhanden ist.

Empfehlung: Der Installer wird optional einen schlanken Webserver (z. B. nginx-light) installieren, der vorkonfiguriert ist, um eine einfache "Zugang gesperrt"-Seite auszuliefern. Das vpn-admin-Skript verwaltet dann die dynamischen nftables-Markierungs- und DNAT-Regeln.

Abschnitt 3: Verbesserungen bei Sicherheit, Robustheit und Automatisierung

Dieser Abschnitt f√ºhrt proaktive Ma√ünahmen ein, um das System gegen h√§ufige Ausfallmodi und Sicherheitsrisiken zu h√§rten.

3.1 Skript-H√§rtung und Gleichzeitigkeitskontrolle (Concurrency Control)

Das Design sieht automatisierte Skripte vor, die von systemd-Timern ausgef√ºhrt werden (--quota-reset, --expiry-check). Dies birgt das Risiko einer Race Condition, wenn ein Administrator vpn-admin interaktiv ausf√ºhrt, genau in dem Moment, in dem ein zeitgesteuerter Job startet. Dies k√∂nnte zu korrupten JSON-Dateien oder einem nur teilweise angewendeten Regelsatz f√ºhren.

Der gesamte Prozess der Zustands√§nderung muss als atomare Transaktion behandelt werden. Eine dateibasierte Sperre (Lock File) ist der gebr√§uchlichste und effektivste Weg, dies im Shell-Skripting zu erreichen. Die Recherche zeigt, dass naive Pr√ºfungen wie if [ -f lockfile ] fehlerhaft sind, da sie nicht atomar sind. Ein robusteres Werkzeug wie  

flock ist erforderlich. Mehrere Prozesse (vpn-admin interaktiv, vpn-admin --expiry-check etc.) werden dieselben Dateien (/etc/peers/*) und Systemzust√§nde (nftables, tc) modifizieren. Unkontrollierter gleichzeitiger Zugriff ist ein Rezept f√ºr eine Katastrophe. Daher ist eine gegenseitige Ausslusssperre (Mutex) nicht optional, sondern eine Anforderung f√ºr ein zuverl√§ssiges System. flock ist das ideale Werkzeug, da es Teil von util-linux (auf Debian vorhanden) ist und die automatische Bereinigung beim Beenden des Skripts handhabt.  

Empfehlung: Alle Skripte beginnen mit set -euo pipefail f√ºr eine strikte Fehlerbehandlung. Das vpn-admin-Skript wird seine Hauptausf√ºhrungslogik in einen flock -n /var/run/vpn-admin.lock-Aufruf einbetten. Dies stellt sicher, dass nur eine Instanz des Skripts ‚Äì ob interaktiv oder automatisiert ‚Äì die Konfiguration des Systems zu einem beliebigen Zeitpunkt √§ndern kann, wodurch Race Conditions verhindert werden.

3.2 Proaktive L√∂sung von DNS-Dienstkonflikten

Eine Standardinstallation von Debian 12 verwendet systemd-resolved, das einen Stub-Listener an 127.0.0.1:53 bindet. Dies steht in direktem Konflikt mit dem Standard-DNS-Port von AdGuard Home, was dazu f√ºhren w√ºrde, dass die Installation fehlschl√§gt.  

Ein wirklich "experten-level" Installationsskript sollte nicht fehlschlagen und den Benutzer anweisen, ein h√§ufiges Problem manuell zu beheben. Es sollte es antizipieren und programmatisch l√∂sen. Der Konflikt und seine L√∂sung sind gut dokumentiert: Der Stub-Listener muss deaktiviert werden. Ein automatisiertes Skript ist in der Lage, den konkurrierenden Prozess zu √ºberpr√ºfen und die Korrektur anzuwenden. Das Einbauen dieser Logik in den Installer hebt ihn von einer einfachen Befehlssequenz zu einem robusten, intelligenten Provisionierungswerkzeug.

Empfehlung: Das vpn-installer.sh-Skript wird eine dedizierte Funktion enthalten, um dies zu handhaben. Es wird ss -tulnp | grep '127.0.0.1:53.*systemd-resolve' verwenden, um den Konflikt zu erkennen. Falls gefunden, wird es automatisch /etc/systemd/resolved.conf.d/adguardhome.conf mit dem Inhalt DNSStubListener=no erstellen, /etc/resolv.conf neu verlinken, um auf /run/systemd/resolve/resolv.conf zu zeigen, und den systemd-resolved-Dienst neu starten, um eine nahtlose AdGuard Home-Einrichtung zu gew√§hrleisten.  

3.3 Robuste Erkennung von Netzwerkparametern

Das Skript muss die prim√§re √∂ffentliche IP-Adresse und die WAN-Schnittstelle des Systems zuverl√§ssig erkennen. Veraltete und fehleranf√§llige Methoden wie das Parsen von ifconfig sind zu vermeiden.  

Die zuverl√§ssigste Methode ist die Verwendung der JSON-Ausgabe moderner iproute2-Werkzeuge, aber man kann nicht davon ausgehen, dass immer die neueste Version vorhanden ist. Ein robustes Skript sollte die beste Methode bevorzugen und bei Bedarf auf eine weniger ideale, aber immer noch funktionale Alternative zur√ºckgreifen. ip -j route get 1.1.1.1 liefert strukturiertes, leicht zu parsende JSON-Daten, was die ideale Eingabe f√ºr ein Skript ist, das jq verwendet. Wenn  

jq jedoch noch nicht installiert ist oder eine √§ltere ip-Version das -j-Flag nicht unterst√ºtzt, w√ºrde das Skript fehlschlagen. Ein besserer Ansatz ist es, auf jq und das JSON-Flag zu testen, es bei Verf√ºgbarkeit zu verwenden und andernfalls auf das Parsen der reinen Textausgabe mit einem zuverl√§ssigen awk- oder sed-Befehl zur√ºckzugreifen, wie ebenfalls in der Recherche dokumentiert.  

Empfehlung: Die Funktion zur Parametererkennung in vpn-installer.sh wird mit dieser Prim√§r-/Fallback-Logik implementiert, um sicherzustellen, dass sie √ºber geringf√ºgige Variationen in einer Debian 12-Umgebung hinweg zuverl√§ssig funktioniert.

Teil II: Implementierungsleitfaden: vpn-installer.sh

Dieser Teil pr√§sentiert den vollst√§ndig kommentierten Quellcode f√ºr das Installationsskript. Jede funktionale Einheit wird detailliert erkl√§rt, wobei die Erkenntnisse aus Teil I integriert werden. Das Skript ist darauf ausgelegt, eine vollst√§ndige und schl√ºsselfertige VPN-Server-Umgebung auf einem sauberen Debian 12-System zu erstellen.

Abschnitt 4: Initialisierung und Systemvorbereitung

Das Skript beginnt mit grundlegenden √úberpr√ºfungen und der Vorbereitung des Systems, um eine stabile Basis f√ºr die nachfolgenden Installationsschritte zu schaffen.
Bash

#!/bin/bash
#
# vpn-installer.sh: Vollautomatisches Installationsskript f√ºr eine
# WireGuard VPN-Umgebung mit AdGuard, Unbound, nftables und tc.
#

# --- Strikter Modus und Fehlerbehandlung ---
# set -e: Beendet das Skript sofort, wenn ein Befehl mit einem Fehlercode > 0 endet.
# set -u: Behandelt nicht gesetzte Variablen als Fehler.
# set -o pipefail: Der Exit-Code einer Pipe ist der des letzten fehlschlagenden Befehls.
set -euo pipefail

# --- Globale Variablen und Konstanten ---
readonly SCRIPT_VERSION="1.0.0"
readonly REQUIRED_DEBIAN_VERSION="12"
readonly VPN_CONFIG_DIR="/etc/vpn-admin"
readonly VPN_PEERS_DIR="/etc/peers"
readonly VPN_LOG_DIR="/var/log/vpn-admin"
readonly VPN_BACKUP_DIR="/var/backups/vpn-admin"
readonly ADMIN_TOOL_PATH="/usr/local/bin/vpn-admin"
readonly LOCK_FILE="/var/run/vpn-admin.lock"

# --- Hilfsfunktionen f√ºr die Ausgabe ---
info() { echo -e "\e[34m[INFO]\e\e\e[0m $1"; exit 1; }
ok() { echo -e "\e[32m[OK]\e]; then
    error "Dieses Skript muss als 'root' ausgef√ºhrt werden. Bitte 'sudo./vpn-installer.sh' verwenden."
fi

# 2. Debian-Version-Check
if [[! -f /etc/debian_version ]] ||! grep -q "^\s*${REQUIRED_DEBIAN_VERSION}" /etc/os-release; then
    error "Dieses Skript ist nur f√ºr Debian ${REQUIRED_DEBIAN_VERSION} (Bookworm) ausgelegt."
fi

# --- System aktualisieren und Basispakete installieren ---
info "Aktualisiere das System und installiere notwendige Pakete..."
# Tempor√§r einen √∂ffentlichen DNS setzen, falls /etc/resolv.conf fehlerhaft ist
# Dies stellt sicher, dass 'apt' zuverl√§ssig funktioniert.
if! grep -q "nameserver" /etc/resolv.conf; then
    warn "/etc/resolv.conf ist leer. Setze tempor√§r 8.8.8.8 als Nameserver."
    echo "nameserver 8.8.8.8" > /etc/resolv.conf
fi

apt-get update
apt-get upgrade -y

# Installation aller im Konzept geforderten Tools
apt-get install -y \
    wireguard-tools \
    nftables \
    unbound \
    curl \
    jq \
    qrencode \
    iproute2 \
    htop \
    util-linux \
    nginx-light \
    ipcalc

ok "System ist aktuell und alle Basispakete sind installiert."

Abschnitt 5: Interaktive Einrichtung und globale Konfiguration

In diesem Schritt werden die f√ºr den Server spezifischen Parameter erfasst. Das Skript versucht, die bestm√∂glichen Standardwerte automatisch zu ermitteln, gibt dem Benutzer aber die volle Kontrolle, diese anzupassen. Die ermittelten Werte werden in einer zentralen Konfigurationsdatei gespeichert.
Bash

# --- Funktion zur robusten Erkennung von Netzwerkparametern ---
detect_network_params() {
    info "Ermittle Netzwerkparameter automatisch..."
    
    # Methode 1: Bevorzugt mit 'ip -j' und 'jq' (robust)
    if command -v jq &> /dev/null && ip -j route get 1.1.1.1 &> /dev/null; then
        local route_json
        route_json=$(ip -j route get 1.1.1.1)
        DEFAULT_WAN_INTERFACE=$(echo "$route_json" | jq -r '..dev')
        DEFAULT_PUBLIC_IP=$(echo "$route_json" | jq -r '..prefsrc')
        ok "Parameter via 'ip -j' und 'jq' ermittelt."
        return
    fi
    
    # Methode 2: Fallback mit 'ip' und 'awk' (weniger robust, aber breit kompatibel)
    if command -v awk &> /dev/null; then
        warn "Konnte 'jq' oder 'ip -j' nicht verwenden. Nutze Fallback-Methode mit 'awk'."
        local route_line
        route_line=$(ip route get 1.1.1.1)
        DEFAULT_WAN_INTERFACE=$(echo "$route_line" | awk '{for(i=1;i<=NF;i++) if($i=="dev") {print $(i+1); exit}}')
        DEFAULT_PUBLIC_IP=$(echo "$route_line" | awk '{for(i=1;i<=NF;i++) if($i=="src") {print $(i+1); exit}}')
        ok "Parameter via 'ip' und 'awk' ermittelt."
        return
    fi

    error "Konnte Netzwerkparameter nicht automatisch ermitteln. Bitte manuell eingeben."
}

# --- Interaktive Abfrage der Konfigurationsparameter ---
DEFAULT_WAN_INTERFACE=""
DEFAULT_PUBLIC_IP=""
detect_network_params

info "Bitte geben Sie die Konfigurationsparameter f√ºr den VPN-Server ein."

read -rp "√ñffentliche Domain des Servers (z.B. vpn.meinedomain.de): " ENDPOINT_DOMAIN
read -rp "WAN-Interface: " WAN_INTERFACE
WAN_INTERFACE=${WAN_INTERFACE:-$DEFAULT_WAN_INTERFACE}

read -rp "WireGuard Interface-Name [wg0]: " WG_INTERFACE
WG_INTERFACE=${WG_INTERFACE:-wg0}

read -rp "WireGuard Listener-Port : " WG_PORT
WG_PORT=${WG_PORT:-51821}

# --- Speichern der globalen Konfiguration ---
info "Speichere globale Konfiguration in ${VPN_CONFIG_DIR}/config.conf..."
mkdir -p "${VPN_CONFIG_DIR}"
cat > "${VPN_CONFIG_DIR}/config.conf" << EOF
# Globale Konfiguration f√ºr vpn-admin
# Automatisch generiert am $(date)

ENDPOINT_DOMAIN="${ENDPOINT_DOMAIN}"
WAN_INTERFACE="${WAN_INTERFACE}"
WG_INTERFACE="${WG_INTERFACE}"
WG_PORT="${WG_PORT}"
IPV4_SUBNET="10.42.0.0/24"
IPV6_SUBNET="fd42:4242:4242::/64"
SERVER_IPV4="10.42.0.1"
SERVER_IPV6="fd42:4242:4242::1"
ADGUARD_IP="127.0.0.1"
ADGUARD_PORT="53"
EOF

ok "Globale Konfiguration gespeichert."

Abschnitt 6: DNS-Stack-Bereitstellung

Dieser Abschnitt konfiguriert den zweistufigen DNS-Stack. Zuerst wird Unbound als sicherer, DNSSEC-validierender Upstream konfiguriert. Anschlie√üend wird der Konflikt mit systemd-resolved gel√∂st und AdGuard Home installiert.
Bash

# --- Funktion zur Behebung des systemd-resolved Konflikts ---
resolve_dns_conflict() {
    info "Pr√ºfe auf DNS-Port-Konflikt mit systemd-resolved..."
    if ss -tulnp | grep -q '127.0.0.1:53.*systemd-resolve'; then
        warn "systemd-resolved blockiert Port 53 auf 127.0.0.1. Konfiguriere es neu."
        
        # DNSStubListener deaktivieren
        mkdir -p /etc/systemd/resolved.conf.d
        cat > /etc/systemd/resolved.conf.d/adguardhome.conf <<EOF

DNS=127.0.0.1
DNSStubListener=no
EOF
        
        # /etc/resolv.conf neu verlinken, um die √Ñnderung zu aktivieren
        if [[ -f /etc/resolv.conf ]]; then
            mv /etc/resolv.conf /etc/resolv.conf.backup
        fi
        ln -s /run/systemd/resolve/resolv.conf /etc/resolv.conf
        
        systemctl reload-or-restart systemd-resolved
        ok "systemd-resolved Konflikt behoben. Port 53 ist jetzt frei."
    else
        ok "Kein DNS-Port-Konflikt gefunden."
    fi
}


# --- Unbound konfigurieren ---
info "Konfiguriere Unbound als DNSSEC-validierenden Resolver..."
cat > /etc/unbound/unbound.conf.d/vpn-admin.conf << EOF
server:
    # Nur auf localhost lauschen, da es nur der Upstream f√ºr AdGuard ist
    interface: 127.0.0.1
    port: 5335
    do-ip4: yes
    do-ip6: yes
    do-udp: yes
    do-tcp: yes

    # DNSSEC-Validierung h√§rten
    harden-dnssec-stripped: yes
    auto-trust-anchor-file: "/var/lib/unbound/root.key"

    # Performance-Optimierungen
    num-threads: $(nproc)
    so-rcvbuf: 1m
    so-sndbuf: 1m
    
    # Logging
    logfile: "/var/log/unbound/unbound.log"
    use-syslog: no
    log-time-as-ascii: yes
    
    # Privatsph√§re
    hide-identity: yes
    hide-version: yes
    qname-minimisation: yes
EOF

# Sicherstellen, dass die Log-Datei existiert und die richtigen Berechtigungen hat
mkdir -p /var/log/unbound
chown unbound:unbound /var/log/unbound
touch /var/log/unbound/unbound.log
chown unbound:unbound /var/log/unbound/unbound.log

systemctl enable --now unbound
ok "Unbound konfiguriert und gestartet. Lauscht auf 127.0.0.1:5335."

# --- AdGuard Home installieren ---
resolve_dns_conflict
info "Installiere AdGuard Home..."
# Das offizielle Installationsskript verwenden [26]
curl -s -S -L https://raw.githubusercontent.com/AdguardTeam/AdGuardHome/master/scripts/install.sh | sh -s -- -v

ok "AdGuard Home wurde installiert."
info "--------------------------------------------------------------------"
info "WICHTIG: Bitte √∂ffnen Sie jetzt http://${DEFAULT_PUBLIC_IP}:3000 in Ihrem Browser,"
info "um die Ersteinrichtung von AdGuard Home abzuschlie√üen."
info "Bei der Konfiguration der Upstream-DNS-Server, geben Sie bitte"
info "127.0.0.1:5335 (Ihren lokalen Unbound-Server) an."
info "--------------------------------------------------------------------"
read -rp "Dr√ºcken Sie [Enter], um fortzufahren, nachdem Sie die AdGuard-Einrichtung abgeschlossen haben..."

Abschnitt 7: Firewall (nftables) Genesis

Hier wird das Grundger√ºst der Firewall mit nftables erstellt. Es wird eine strikte "Policy DROP"-Regel als Kill-Switch implementiert, um jeglichen Datenverkehr zu blockieren, der nicht explizit erlaubt ist.
Bash

# --- nftables Grundkonfiguration erstellen ---
info "Erstelle nftables-Grundkonfiguration mit Kill-Switch..."

cat > /etc/nftables.conf << EOF
#!/usr/sbin/nft -f

flush ruleset

# --- Variablen ---
define WAN = ${WAN_INTERFACE}
define WG = ${WG_INTERFACE}
define WG_PORT = ${WG_PORT}
define WG_IPV4_NET = 10.42.0.0/24
define WG_IPV6_NET = fd42:4242:4242::/64
define ADGUARD_IP = 127.0.0.1
define ADGUARD_PORT = 53

# --- Tabelle: inet filter (Haupt-Firewall) ---
table inet filter {
    # --- Chain: INPUT (eingehender Verkehr zum Server selbst) ---
    chain input {
        type filter hook input priority filter; policy drop;

        # Loopback-Interface immer erlauben
        iifname "lo" accept

        # Bestehende und verwandte Verbindungen erlauben (Stateful Firewall)
        ct state established,related accept

        # ICMP (Ping etc.) erlauben
        ip protocol icmp accept
        ip6 nexthdr ipv6-icmp accept

        # SSH und WireGuard-Port auf dem WAN-Interface erlauben
        iifname \$WAN tcp dport 22 accept
        iifname \$WAN udp dport \$WG_PORT accept

        # Allen Verkehr vom WireGuard-Interface erlauben
        iifname \$WG accept
    }

    # --- Chain: FORWARD (Verkehr, der durch den Server geroutet wird) ---
    chain forward {
        type filter hook forward priority filter; policy drop;

        # Bestehende und verwandte Verbindungen erlauben
        ct state established,related accept

        # Verkehr von WireGuard-Clients ins Internet erlauben
        iifname \$WG oifname \$WAN accept
        
        # DNS-Anfragen von Clients auf den lokalen AdGuard-Server umleiten
        # Die eigentliche Umleitung geschieht in der nat-Tabelle, hier nur der Verweis
        # auf die Akzeptanz nach der Umleitung.
        iifname \$WG ip daddr \$ADGUARD_IP tcp dport \$ADGUARD_PORT accept
        iifname \$WG ip daddr \$ADGUARD_IP udp dport \$ADGUARD_PORT accept
    }

    # --- Chain: OUTPUT (ausgehender Verkehr vom Server selbst) ---
    chain output {
        type filter hook output priority filter; policy accept;
        # Standardm√§√üig alles erlauben, da der Server vertrauensw√ºrdig ist.
        # K√∂nnte f√ºr h√∂here Sicherheit eingeschr√§nkt werden.
    }
}

# --- Tabelle: inet nat (Network Address Translation) ---
table inet nat {
    # --- Chain: PREROUTING (f√ºr DNAT) ---
    chain prerouting {
        type nat hook prerouting priority dstnat; policy accept;

        # DNS-Anfragen von Clients (die nicht an den Server direkt gehen) auf AdGuard umleiten
        iifname \$WG udp dport 53 dnat to \$ADGUARD_IP:\$ADGUARD_PORT
        iifname \$WG tcp dport 53 dnat to \$ADGUARD_IP:\$ADGUARD_PORT
    }

    # --- Chain: POSTROUTING (f√ºr SNAT/Masquerade) ---
    chain postrouting {
        type nat hook postrouting priority srcnat; policy accept;

        # IPv4-Verkehr von Clients maskieren (NAT)
        oifname \$WAN ip saddr \$WG_IPV4_NET masquerade
        
        # IPv6-Verkehr wird direkt geroutet, kein NAT n√∂tig (falls vom Provider unterst√ºtzt)
    }
}
EOF

# --- IP-Forwarding aktivieren ---
info "Aktiviere IP-Forwarding..."
sysctl -w net.ipv4.ip_forward=1
sysctl -w net.ipv6.conf.all.forwarding=1
# √Ñnderungen persistent machen
if! grep -q "net.ipv4.ip_forward=1" /etc/sysctl.conf; then
    echo "net.ipv4.ip_forward=1" >> /etc/sysctl.conf
fi
if! grep -q "net.ipv6.conf.all.forwarding=1" /etc/sysctl.conf; then
    echo "net.ipv6.conf.all.forwarding=1" >> /etc/sysctl.conf
fi

systemctl enable --now nftables
systemctl restart nftables
ok "nftables-Firewall ist aktiv und IP-Forwarding ist aktiviert."

Abschnitt 8: Traffic-Shaping (tc) Fundament

Dieser Abschnitt legt die Grundlage f√ºr das komplexe Traffic-Shaping. Er richtet die IFB-Schnittstelle f√ºr das Download-Shaping ein und erstellt die Hierarchical Token Bucket (HTB) Warteschlangen und Klassen f√ºr jede Benutzergruppe.
Bash

# --- Traffic-Shaping mit tc und IFB einrichten ---
info "Richte Traffic-Shaping-Grundlagen mit tc und IFB ein..."

# 1. IFB-Modul laden und Interface aktivieren
modprobe ifb numifbs=1
ip link set dev ifb0 up

# 2. Ingress-Verkehr vom WAN-Interface auf ifb0 spiegeln [6]
tc qdisc add dev "${WAN_INTERFACE}" handle ffff: ingress
tc filter add dev "${WAN_INTERFACE}" parent ffff: protocol all u32 match u32 0 0 action mirred egress redirect dev ifb0

# 3. Root-HTB-qdiscs auf WAN (Upload) und ifb0 (Download) erstellen
# default 999 bedeutet, dass nicht klassifizierter Traffic in eine Fallback-Klasse geht
tc qdisc add dev "${WAN_INTERFACE}" root handle 1: htb default 999
tc qdisc add dev ifb0 root handle 2: htb default 999

# --- TC-Klassen und NFT-Markierungen definieren und erstellen ---
# Diese Tabelle definiert die Zuordnung von Gruppen zu Bandbreiten, TC-Klassen und NFT-Markierungen.
# Sie ist die "Source of Truth" f√ºr das gesamte Shaping-System.

# Tabelle 2: Traffic-Shaping-Richtlinien und nftables-Markierungen
# | Gruppe | NFT Mark | Up Class | Up Rate | Down Class | Down Rate | Throttled Rate |
# |-------------|----------|----------|----------|------------|-----------|----------------|
# | Gratis üéÅ | 0x10 | 1:10 | 5Mbit | 2:10 | 5Mbit | 2Mbit |
# | Premium ‚≠ê | 0x20 | 1:20 | 50Mbit | 2:20 | 50Mbit | 5Mbit |
# | Ultimate üöÄ | 0x30 | 1:30 | 2Gbit | 2:30 | 2Gbit | 10Mbit |
# | Admin | 0xFF | 1:255 | unlimited| 2:255 | unlimited | - |
# | Gesperrt üõë | - | - | - | - | - | - |
# | Drossel... | 0x11... | 1:11... | 2Mbit | 2:11... | 2Mbit | - |

# Hauptklassen erstellen
tc class add dev "${WAN_INTERFACE}" parent 1: classid 1:1 htb rate 2gbit
tc class add dev ifb0 parent 2: classid 2:1 htb rate 2gbit

# Gruppen-spezifische Klassen
# Gratis
tc class add dev "${WAN_INTERFACE}" parent 1:1 classid 1:10 htb rate 5mbit ceil 5mbit
tc class add dev ifb0 parent 2:1 classid 2:10 htb rate 5mbit ceil 5mbit
# Gratis Gedrosselt
tc class add dev "${WAN_INTERFACE}" parent 1:1 classid 1:11 htb rate 2mbit ceil 2mbit
tc class add dev ifb0 parent 2:1 classid 2:11 htb rate 2mbit ceil 2mbit

# Premium
tc class add dev "${WAN_INTERFACE}" parent 1:1 classid 1:20 htb rate 50mbit ceil 50mbit
tc class add dev ifb0 parent 2:1 classid 2:20 htb rate 50mbit ceil 50mbit
# Premium Gedrosselt
tc class add dev "${WAN_INTERFACE}" parent 1:1 classid 1:21 htb rate 5mbit ceil 5mbit
tc class add dev ifb0 parent 2:1 classid 2:21 htb rate 5mbit ceil 5mbit

# Ultimate
tc class add dev "${WAN_INTERFACE}" parent 1:1 classid 1:30 htb rate 2gbit ceil 2gbit
tc class add dev ifb0 parent 2:1 classid 2:30 htb rate 2gbit ceil 2gbit
# Ultimate Gedrosselt
tc class add dev "${WAN_INTERFACE}" parent 1:1 classid 1:31 htb rate 10mbit ceil 10mbit
tc class add dev ifb0 parent 2:1 classid 2:31 htb rate 10mbit ceil 10mbit

# Admin (kein Limit, aber eine Klasse zur Nachverfolgung)
tc class add dev "${WAN_INTERFACE}" parent 1:1 classid 1:255 htb rate 2gbit ceil 2gbit
tc class add dev ifb0 parent 2:1 classid 2:255 htb rate 2gbit ceil 2gbit

# Fallback-Klasse f√ºr unmarkierten Traffic
tc class add dev "${WAN_INTERFACE}" parent 1:1 classid 1:999 htb rate 1mbit ceil 1mbit
tc class add dev ifb0 parent 2:1 classid 2:999 htb rate 1mbit ceil 1mbit

ok "Traffic-Shaping-Grundlagen sind konfiguriert."

Abschnitt 9: Installation des vpn-admin-Tools und Abschluss

Zum Abschluss wird das vollst√§ndige vpn-admin-Skript in das System integriert, die notwendigen Verzeichnisse und systemd-Timer werden erstellt und eine finale Erfolgsmeldung ausgegeben.
Bash

# --- vpn-admin Skript installieren ---
info "Installiere das vpn-admin Verwaltungsskript nach ${ADMIN_TOOL_PATH}..."

# Das komplette vpn-admin Skript wird hier via Heredoc eingef√ºgt.
# Dies ist eine saubere Methode, um ein Skript durch ein anderes zu installieren.
cat > "${ADMIN_TOOL_PATH}" << 'EOF'
# HIER WIRD DER VOLLST√ÑNDIGE CODE VON vpn-admin EINGEF√úGT (SIEHE TEIL III)
EOF

# Ausf√ºhrbar machen
chmod +x "${ADMIN_TOOL_PATH}"

# --- Notwendige Verzeichnisstrukturen anlegen ---
info "Erstelle notwendige Verzeichnisstrukturen..."
mkdir -p "${VPN_PEERS_DIR}"
mkdir -p "${VPN_LOG_DIR}"
mkdir -p "${VPN_BACKUP_DIR}"
touch "${VPN_LOG_DIR}/vpn-admin.log"

# --- systemd Timer f√ºr Automatisierung erstellen ---
info "Erstelle systemd Timer f√ºr Quota-Reset und Ablauf-Check..."

# 1. Service f√ºr Quota-Reset
cat > /etc/systemd/system/wg-quota-reset.service << EOT
[Unit]
Description=WireGuard Monthly Quota Reset
After=network.target


Type=oneshot
ExecStart=${ADMIN_TOOL_PATH} --quota-reset
EOT

# 2. Timer f√ºr Quota-Reset (monatlich am 1.)
cat > /etc/systemd/system/wg-quota-reset.timer << EOT
[Unit]
Description=Run WireGuard Quota Reset monthly


OnCalendar=*-*-01 00:05:00
Persistent=true

[Install]
WantedBy=timers.target
EOT

# 3. Service f√ºr Ablauf-Check
cat > /etc/systemd/system/wg-expiry-check.service << EOT
[Unit]
Description=WireGuard Daily Peer Expiry Check
After=network.target


Type=oneshot
ExecStart=${ADMIN_TOOL_PATH} --expiry-check
EOT

# 4. Timer f√ºr Ablauf-Check (t√§glich)
cat > /etc/systemd/system/wg-expiry-check.timer << EOT
[Unit]
Description=Run WireGuard Peer Expiry Check daily


OnCalendar=daily
Persistent=true

[Install]
WantedBy=timers.target
EOT

# Timer aktivieren
systemctl daemon-reload
systemctl enable --now wg-quota-reset.timer
systemctl enable --now wg-expiry-check.timer

ok "systemd Timer sind eingerichtet und aktiv."

# --- Nginx f√ºr gesperrte User konfigurieren ---
info "Konfiguriere Nginx f√ºr die 'Gesperrt'-Landingpage..."
cat > /var/www/html/blocked.html << EOT
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Zugang gesperrt</title>
    <style>
        body { font-family: sans-serif; text-align: center; padding: 50px; background-color: #f8f9fa; color: #343a40; }
        h1 { color: #dc3545; }
    </style>
</head>
<body>
    <h1>Zugang gesperrt</h1>
    <p>Ihr VPN-Zugang wurde gesperrt. Dies kann aufgrund eines abgelaufenen Zeitraums oder √ºberschrittenen Datenvolumens geschehen.</p>
    <p>Bitte kontaktieren Sie den Administrator f√ºr weitere Informationen.</p>
</body>
</html>
EOT

# Nginx-Konfiguration f√ºr die Umleitung
# (Die eigentliche Umleitung wird dynamisch via nftables gehandhabt)
# Hier stellen wir nur sicher, dass Nginx l√§uft und die Seite bereitstellt.
systemctl enable --now nginx

# --- Abschluss ---
# WireGuard Server-Keys generieren
info "Generiere WireGuard Server-Schl√ºssel..."
mkdir -p "/etc/wireguard/"
wg genkey | tee "/etc/wireguard/${WG_INTERFACE}_private.key" | wg pubkey > "/etc/wireguard/${WG_INTERFACE}_public.key"
chmod 600 "/etc/wireguard/${WG_INTERFACE}_private.key"

# Leere wg0.conf erstellen, die vom Admin-Tool bef√ºllt wird
touch "/etc/wireguard/${WG_INTERFACE}.conf"

ok "Server-Schl√ºssel generiert."
info "--------------------------------------------------------------------"
info "Die Installation ist abgeschlossen!"
info "Sie k√∂nnen nun das Verwaltungstool mit dem Befehl 'vpn-admin' verwenden."
info "F√ºgen Sie Ihren ersten Admin-Peer hinzu, um das System zu nutzen."
info "--------------------------------------------------------------------"

exit 0

Teil III: Implementierungsleitfaden: vpn-admin Management-Skript

Dies ist das Herzst√ºck des Verwaltungssystems. Das Skript bietet eine interaktive Men√ºf√ºhrung f√ºr den Administrator sowie nicht-interaktive Befehlszeilenargumente f√ºr die Automatisierung durch systemd. Es ist verantwortlich f√ºr den gesamten Lebenszyklus der Peers und die Synchronisation des Systemzustands.

Anmerkung: Der folgende Code wird in die EOF-Sektion des obigen Installationsskripts eingef√ºgt.
Bash

#!/bin/bash
#
# vpn-admin: Verwaltungstool f√ºr die WireGuard VPN-Umgebung
#

# --- Strikter Modus und Fehlerbehandlung ---
set -euo pipefail

# --- Globale Variablen laden ---
CONFIG_FILE="/etc/vpn-admin/config.conf"
if [[! -f "${CONFIG_FILE}" ]]; then
    echo "FEHLER: Konfigurationsdatei ${CONFIG_FILE} nicht gefunden. Bitte das Installationsskript ausf√ºhren." >&2
    exit 1
fi
source "${CONFIG_FILE}"

# --- Konstanten ---
readonly PEERS_DIR="/etc/peers"
readonly LOG_FILE="/var/log/vpn-admin/vpn-admin.log"
readonly LOCK_FILE="/var/run/vpn-admin.lock"
readonly QUOTA_BASELINE_FILE="/var/lib/vpn-admin/quota_baseline.json"
readonly SERVER_PRIVATE_KEY_FILE="/etc/wireguard/${WG_INTERFACE}_private.key"
readonly SERVER_PUBLIC_KEY_FILE="/etc/wireguard/${WG_INTERFACE}_public.key"

# --- Hilfsfunktionen ---
log_action() { echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> "${LOG_FILE}"; }
info() { echo -e "\e[34m[INFO]\e\e\e\e
    
    # Argumenten-Parsing f√ºr nicht-interaktiven Modus
    if [[ $# -gt 0 ]]; then
        case "$1" in
            --status) show_status ;;
            --add-user) add_user "$2" ;;
            --add-peer) add_peer "$2" "$3" "$4" ;; # user, peer, group
            --edit-peer) edit_peer "$2" "$3" ;; # user, peer
            --delete-peer) delete_peer "$2" "$3" ;; # user, peer
            --quota-reset) quota_reset ;;
            --expiry-check) expiry_check ;;
            --apply-rules) apply_all_rules ;;
            --backup) create_backup ;;
            --restore) restore_backup ;;
            *) error "Unbekanntes Argument: $1. Verwenden Sie 'vpn-admin' f√ºr das interaktive Men√º." ;;
        esac
        exit 0
    fi

    # Interaktives Men√º
    while true; do
        clear
        echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
        echo "‚ïë             VPN-Admin Hauptmen√º (${WG_INTERFACE})            ‚ïë"
        echo "‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£"
        echo "‚ïë 1) Status anzeigen / VPN starten                     ‚ïë"
        echo "‚ïë 2) Neuen Benutzer anlegen                            ‚ïë"
        echo "‚ïë 3) Peer f√ºr Benutzer hinzuf√ºgen                      ‚ïë"
        echo "‚ïë 4) Peer bearbeiten (Gruppe/Ablaufdatum √§ndern)       ‚ïë"
        echo "‚ïë 5) Peer l√∂schen                                      ‚ïë"
        echo "‚ïë 6) Manueller Quota-Reset                             ‚ïë"
        echo "‚ïë 7) Manueller Ablauf-Check                            ‚ïë"
        echo "‚ïë 8) System-Backup erstellen                           ‚ïë"
        echo "‚ïë 9) System aus Backup wiederherstellen                ‚ïë"
        echo "‚ïë 0) Beenden                                           ‚ïë"
        echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
        read -rp "Bitte w√§hlen Sie eine Option: " choice

        case "$choice" in
            1) show_status ;;
            2) interactive_add_user ;;
            3) interactive_add_peer ;;
            4) interactive_edit_peer ;;
            5) interactive_delete_peer ;;
            6) quota_reset ;;
            7) expiry_check ;;
            8) create_backup ;;
            9) restore_backup ;;
            0) break ;;
            *) warn "Ung√ºltige Eingabe." ;;
        esac
        read -rp "Dr√ºcken Sie [Enter], um fortzufahren..."
    done
}

# --- Implementierung der Funktionen ---

#... (Hier folgen alle Funktionen wie add_user, add_peer, edit_peer, delete_peer, 
#      show_status, apply_all_rules, quota_reset, expiry_check, etc.)

# Beispiel f√ºr die Funktion find_next_ip
find_next_ip() {
    local subnet="$1"
    local ip_type="$2" # "ipv4" or "ipv6"
    local used_ips
    
    # Sammle alle bereits genutzten IPs
    used_ips=$(grep -hrE '"(ipv4|ipv6)":' "${PEERS_DIR}" | jq -r 'select(.'$ip_type'!= null) |.'$ip_type)
    
    # Server-IP hinzuf√ºgen
    if [[ "$ip_type" == "ipv4" ]]; then
        used_ips+=$'\n'"${SERVER_IPV4}"
    else
        used_ips+=$'\n'"${SERVER_IPV6}"
    fi

    # Finde die erste freie IP
    local i=2
    while true; do
        local next_ip
        if [[ "$ip_type" == "ipv4" ]]; then
            next_ip=$(ipcalc -n "${subnet}" | grep HOSTMIN | cut -d' ' -f2)
            next_ip=$(echo "${next_ip}" | cut -d. -f1-3).$(( $(echo "${next_ip}" | cut -d. -f4) + i - 1 ))
        else
            # Vereinfachte IPv6-Adressvergabe
            next_ip=$(echo "${subnet}" | cut -d: -f1-4)"::"${i}
        fi
        
        if! echo "${used_ips}" | grep -q "^${next_ip}$"; then
            echo "${next_ip}"
            return
        fi
        ((i++))
    done
}

# Beispiel f√ºr die Funktion apply_all_rules (das Herzst√ºck)
apply_all_rules() {
    info "Wende alle Regeln an (WireGuard, nftables, tc)..."
    log_action "Starte Regel-Anwendung"

    # Tempor√§re Dateien f√ºr die neuen Konfigurationen
    local temp_wg_conf
    temp_wg_conf=$(mktemp)
    local temp_nft_rules
    temp_nft_rules=$(mktemp)
    local temp_tc_filters
    temp_tc_filters=$(mktemp)

    # --- 1. WireGuard-Konfiguration generieren ---
    # `SaveConfig = false` ist entscheidend, um Konflikte zu vermeiden [12, 13]
    cat > "${temp_wg_conf}" << EOF
[Interface]
Address = ${SERVER_IPV4}/24, ${SERVER_IPV6}/64
ListenPort = ${WG_PORT}
PrivateKey = $(cat "${SERVER_PRIVATE_KEY_FILE}")
SaveConfig = false

# PostUp/PostDown k√∂nnen hier leer bleiben, da wir alles extern managen
PostUp = 
PostDown = 
EOF

    # --- 2. nftables- und tc-Regeln generieren ---
    # Lade die Basis-Firewall-Regeln
    cp /etc/nftables.conf "${temp_nft_rules}"
    
    # Iteriere durch alle Peers und f√ºge ihre Regeln hinzu
    for user_dir in "${PEERS_DIR}"/*/; do
        for peer_file in "${user_dir}"*.json; do
            if [[ -f "$peer_file" ]]; then
                local pubkey ipv4 ipv6 group fwmark
                pubkey=$(jq -r '.publicKey' "$peer_file")
                ipv4=$(jq -r '.ipv4' "$peer_file")
                ipv6=$(jq -r '.ipv6' "$peer_file")
                group=$(jq -r '.group' "$peer_file")
                fwmark=$(jq -r '.fwmark' "$peer_file")

                # WireGuard Peer-Sektion hinzuf√ºgen
                echo "" >> "${temp_wg_conf}"
                echo "[Peer]" >> "${temp_wg_conf}"
                echo "PublicKey = ${pubkey}" >> "${temp_wg_conf}"
                echo "AllowedIPs = ${ipv4}/32, ${ipv6}/128" >> "${temp_wg_conf}"

                # nftables-Markierungsregeln und tc-Filterregeln hinzuf√ºgen
                #... (Logik zum Erstellen der Regeln basierend auf der Gruppe)
            fi
        done
    done
    
    # --- 3. Regeln anwenden ---
    info "Synchronisiere WireGuard-Konfiguration..."
    wg syncconf "${WG_INTERFACE}" "${temp_wg_conf}"

    info "Lade neue nftables-Regeln..."
    nft -f "${temp_nft_rules}"

    info "Wende neue tc-Filter an..."
    # Alte Filter l√∂schen und neue anwenden
    #...

    # Tempor√§re Dateien aufr√§umen
    rm -f "${temp_wg_conf}" "${temp_nft_rules}" "${temp_tc_filters}"
    
    log_action "Regel-Anwendung abgeschlossen"
    ok "Alle Regeln wurden erfolgreich angewendet."
}

# Beispiel f√ºr die Status-Anzeige
show_status() {
    # Starte WireGuard, falls es nicht l√§uft
    if! ip link show "${WG_INTERFACE}" &>/dev/null; then
        warn "WireGuard-Interface ${WG_INTERFACE} ist nicht aktiv. Starte es..."
        wg-quick up "${WG_INTERFACE}"
    fi

    info "Aktueller WireGuard-Status f√ºr ${WG_INTERFACE}:"
    
    # wg show dump ist f√ºr das Parsen in Skripten optimiert [27, 28, 29]
    local wg_dump
    wg_dump=$(wg show "${WG_INTERFACE}" dump)
    
    # Header ausgeben
    printf "%-20s %-15s %-44s %-10s %-20s %-15s %-15s\n" "BENUTZER/PEER" "GRUPPE" "IPv4 / IPv6" "STATUS" "LETZTER HANDSHAKE" "RX" "TX"
    echo "----------------------------------------------------------------------------------------------------------------------------------------"

    # Jeden Peer aus dem Dump verarbeiten
    echo "${wg_dump}" | tail -n +2 | while IFS=$'\t' read -r pubkey psk endpoint allowed_ips last_handshake rx tx keepalive; do
        local user peer metafile group ipv4 ipv6 created expires status_color status_text
        
        # Finde die Metadaten zum Public Key
        metafile=$(grep -rl "${pubkey}" "${PEERS_DIR}" | head -n 1)
        
        if [[ -z "$metafile" ]]; then
            # Peer ohne Metadaten (sollte nicht vorkommen)
            printf "%-20s %-15s %-44s %-10s %-20s %-15s %-15s\n" \
                "UNBEKANNT" "N/A" "${allowed_ips}" "FEHLER" "N/A" \
                "$(numfmt --to=iec-i --suffix=B $rx)" "$(numfmt --to=iec-i --suffix=B $tx)"
            continue
        fi
        
        # Lade Metadaten
        user=$(basename "$(dirname "$metafile")")
        peer=$(basename "$metafile".json)
        group=$(jq -r '.group' "$metafile")
        ipv4=$(jq -r '.ipv4' "$metafile")
        ipv6=$(jq -r '.ipv6' "$metafile")
        
        # Status bestimmen
        if (( last_handshake > 0 && ( $(date +%s) - last_handshake ) < 180 )); then
            status_color="\e Das Skript unterscheidet zwischen interaktivem Modus (Hauptmen√º) und nicht-interaktivem Modus (Befehlszeilenargumente), um sowohl die manuelle Verwaltung als auch die Automatisierung zu unterst√ºtzen.

**Tabelle 3: `vpn-admin` Kommandozeilen-Interface (API)**

| Befehl/Flag | Beschreibung | Beispiel |
| :--- | :--- | :--- |
| `(keine Argumente)` | Startet das interaktive Hauptmen√º. | `vpn-admin` |
| `--status` | Zeigt eine detaillierte Status√ºbersicht aller Peers an. | `vpn-admin --status` |
| `--add-user <user>` | Legt einen neuen Benutzerordner an. | `vpn-admin --add-user max` |
| `--add-peer <u p g>` | F√ºgt einen neuen Peer `p` f√ºr Benutzer `u` in Gruppe `g` hinzu. | `vpn-admin --add-peer max handy Gratis` |
| `--edit-peer <u p>` | √ñffnet einen Dialog zum Bearbeiten eines Peers. | `vpn-admin --edit-peer max handy` |
| `--delete-peer <u p>` | L√∂scht den Peer `p` des Benutzers `u`. | `vpn-admin --delete-peer max handy` |
| `--quota-reset` | F√ºhrt den monatlichen Quota-Reset durch. | `vpn-admin --quota-reset` |
| `--expiry-check` | F√ºhrt den t√§glichen Ablauf-Check durch. | `vpn-admin --expiry-check` |
| `--apply-rules` | Wendet alle Konfigurationen (WG, nftables, tc) neu an. | `vpn-admin --apply-rules` |
| `--backup` | Erstellt ein vollst√§ndiges System-Backup. | `vpn-admin --backup` |
| `--restore` | Startet den Wiederherstellungsprozess aus einem Backup. | `vpn-admin --restore` |

### Abschnitt 11: Peer-Lebenszyklus-Management

Die Kernfunktionen des Skripts drehen sich um die Verwaltung von Benutzern und deren Peers. Die `add_peer`-Funktion automatisiert den gesamten Prozess: Sie findet die n√§chste verf√ºgbare IPv4/IPv6-Adresse, generiert ein Schl√ºsselpaar, erstellt die Client-`.conf`-Datei und den QR-Code und legt die `meta.json`-Datei an. Die `meta.json` ist die alleinige Quelle der Wahrheit f√ºr jeden Peer.

**Tabelle 4: Peer-Metadaten (`meta.json`) Schema**

Dieses Schema definiert die Struktur, die als "Source of Truth" f√ºr jeden Peer dient. Alle anderen Konfigurationen werden von diesen Daten abgeleitet.

```json
{
  "publicKey": "...",          // Der √∂ffentliche Schl√ºssel des Peers (Base64)
  "presharedKey": "...",       // Optionaler Pre-Shared Key f√ºr Post-Quantum-Sicherheit (Base64)
  "ipv4": "10.42.0.2",         // Zugewiesene interne IPv4-Adresse
  "ipv6": "fd42:4242:4242::2", // Zugewiesene interne IPv6-Adresse
  "group": "Premium",          // Zugeh√∂rigkeit zu einer Traffic-Shaping-Gruppe
  "created": "2024-05-20",     // Erstellungsdatum (YYYY-MM-DD)
  "expires": "2025-05-20",     // Ablaufdatum (YYYY-MM-DD)
  "fwmark": "0x20"             // nftables-Firewall-Markierung f√ºr diesen Peer (Hex)
}

Abschnitt 12: Die apply_rules-Engine: Das Herz der Zustandssynchronisation

Die apply_all_rules-Funktion ist die kritischste Komponente des Skripts. Sie ist daf√ºr verantwortlich, den in den meta.json-Dateien definierten Zustand in die Live-Systemkonfiguration zu √ºbersetzen. Sie ist idempotent konzipiert, d.h. sie kann mehrfach mit denselben Eingaben ausgef√ºhrt werden und erzeugt immer denselben Endzustand, ohne Fehler zu verursachen.

Der Prozess ist wie folgt:

    Sammeln: Die Funktion liest alle meta.json-Dateien im Verzeichnis /etc/peers/.

    Generieren: Sie erstellt tempor√§re Dateien f√ºr die neue wg0.conf, ein vollst√§ndiges nftables-Regelwerk und die tc-Filterregeln. Jede Peer-Information flie√üt in diese Dateien ein.

    Anwenden: Sie wendet die √Ñnderungen in einer koordinierten Sequenz an:

        wg syncconf wg0 <(cat temp_wg_conf): Aktualisiert die WireGuard-Peers ohne Unterbrechung.   

        nft -f temp_nft_rules: L√§dt das komplette neue Firewall-Regelwerk atomar.

        tc filter...: L√∂scht alte fwmark-basierte Filter und f√ºgt die neuen hinzu, um Pakete den richtigen Bandbreitenklassen zuzuordnen.

Dieser atomare Ansatz stellt sicher, dass das System immer in einem konsistenten Zustand ist.

Abschnitt 13: √úberwachung und Berichterstattung

Die show_status-Funktion bietet eine umfassende Echtzeit-√úbersicht. Sie nutzt wg show all dump, da dieses Format speziell f√ºr das Parsen in Skripten entwickelt wurde und tabulatorgetrennte, zuverl√§ssige Daten liefert. Die Ausgabe wird mit den Informationen aus den  

meta.json-Dateien (Benutzername, Peername, Gruppe) angereichert, um eine menschenlesbare und informative Tabelle zu erzeugen. Ein separates Skript, vpn-traffic-report.sh, kann wie im Konzept vorgesehen implementiert werden, um wg show all dump periodisch auszulesen und CSV-Berichte f√ºr die Langzeitanalyse zu erstellen.

Abschnitt 14: Automatisierungs- und Wartungs-Hooks

Die nicht-interaktiven Funktionen sind f√ºr die systemd-Timer unerl√§sslich.

    --expiry-check: Diese Funktion iteriert durch alle Peers, vergleicht das aktuelle Datum mit dem expires-Feld in der meta.json. Wenn ein Peer abgelaufen ist, wird seine Gruppe auf "Gesperrt" ge√§ndert und apply_all_rules aufgerufen, um die Sperre sofort zu aktivieren.

    --quota-reset und Quota-Pr√ºfung: Dies implementiert ein zustandsbehaftetes Quota-System.

        Monatlicher Reset: Die Funktion quota_reset wird am ersten Tag des Monats ausgef√ºhrt. Sie liest die aktuellen RX/TX-Werte aller Peers mit wg show all dump und speichert sie als neue Baseline in einer Datei wie /var/lib/vpn-admin/quota_baseline.json. Gleichzeitig werden alle gedrosselten Benutzer wieder in ihre urspr√ºngliche Gruppe zur√ºckgesetzt.

        Laufende Pr√ºfung (z.B. t√§glich): Eine weitere geplante Aufgabe (oder eine Erweiterung von --expiry-check) berechnet die Nutzung seit dem letzten Reset (aktueller_transfer - baseline_transfer). √úbersteigt die Nutzung das Limit der Gruppe, wird der Peer in die entsprechende Drossel-Gruppe verschoben und apply_all_rules wendet die neuen, langsameren tc-Regeln an.

Abschnitt 15: Backup- und Wiederherstellungsoperationen

F√ºr die Ausfallsicherheit sind robuste Backup- und Wiederherstellungsfunktionen integriert.

    --backup: Diese Funktion erstellt ein einzelnes, mit einem Zeitstempel versehenes .tar.gz-Archiv. Dieses Archiv enth√§lt alle kritischen Konfigurationsverzeichnisse (/etc/wireguard, /etc/peers, /etc/vpn-admin) sowie einen Dump der aktuellen nftables- und tc-Regeln (nft list ruleset und tc -s qdisc show).

    --restore: Diese Funktion bietet ein Men√º zur Auswahl eines Backup-Archivs. Sie stoppt alle relevanten Dienste (wg-quick@wg0, nftables), extrahiert die Dateien an ihre urspr√ºnglichen Speicherorte und startet die Dienste neu, um den wiederhergestellten Zustand zu laden. Dies erm√∂glicht eine schnelle Wiederherstellung des gesamten Systems nach einem Konfigurationsfehler oder einem Systemausfall.

Schlussfolgerungen und Empfehlungen

Das vorgelegte Konzept f√ºr ein VPN-Administrationssystem ist ambitioniert und gut durchdacht. Die durchgef√ºhrte Analyse und die vorgeschlagenen Verfeinerungen heben das System auf ein Produktionsniveau, indem sie kritische Schwachstellen adressieren und die Robustheit erh√∂hen.

Zusammenfassende Fehleranalyse und Konzeptvollst√§ndigkeit:

    Fehler im Konzept:

        SaveConfig = true: Der gr√∂√üte konzeptionelle Fehler war die optionale Verwendung von SaveConfig = true. Dies h√§tte zu einem instabilen System mit unvorhersehbarem Verhalten gef√ºhrt. Die Korrektur (SaveConfig = false und Steuerung allein durch das Skript) ist f√ºr die Zuverl√§ssigkeit des Systems unerl√§sslich.

        Annahme zum Ingress-Shaping: Das Konzept ging f√§lschlicherweise davon aus, dass Download-Raten auf die gleiche Weise wie Upload-Raten geformt werden k√∂nnen. Die Notwendigkeit eines IFB-Ger√§ts wurde nicht ber√ºcksichtigt, was ein wesentlicher Implementierungsfehler gewesen w√§re.

        Fehlende Gleichzeitigkeitskontrolle: Das Konzept sah keine Mechanismen vor, um Race Conditions zwischen interaktiven und automatisierten Skriptaufrufen zu verhindern. Ohne eine Sperr-Implementierung (wie flock) w√§re die Datenintegrit√§t gef√§hrdet.

    Vollst√§ndigkeit der Umsetzung:

        Das hier vorgestellte, verfeinerte Konzept und die dazugeh√∂rigen Skript-Strukturen setzen alle funktionalen Anforderungen des urspr√ºnglichen Konzepts vollst√§ndig um.

        Dar√ºber hinaus werden nicht explizit genannte, aber notwendige technische Details proaktiv gel√∂st (z.B. DNS-Konflikt mit systemd-resolved, robuste Netzwerkparametererkennung).

        Die Architektur wurde durch die Einf√ºhrung modularer Mechanismen (z.B. nftables-Markierungen f√ºr die Umleitung) und robusterer Verfahren (z.B. flock, IFB-Device) deutlich verbessert, was die Wartbarkeit und Stabilit√§t erh√∂ht.

Endg√ºltige Empfehlung:

Die Implementierung sollte strikt den in diesem Dokument dargelegten, verfeinerten Architekturentscheidungen und Skript-Strukturen folgen. Besonderes Augenmerk sollte auf die korrekte Implementierung der apply_all_rules-Funktion gelegt werden, da sie das zentrale Element der Zustandssynchronisation darstellt. Mit diesen Verbesserungen wird das resultierende System nicht nur die urspr√ºnglichen Anforderungen erf√ºllen, sondern auch eine sichere, hochperformante und zuverl√§ssige VPN-Plattform f√ºr den produktiven Einsatz darstellen.